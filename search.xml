<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[koa2开发后台服务 - (3) nodejs连接redis]]></title>
    <url>%2F2020%2F03%2F02%2Fkoa2-redis%2F</url>
    <content type="text"><![CDATA[redis是一个内存数据库，和类似mysql这种硬盘关系型数据库相比，它的典型特点就是数据存储在内存中，访问速度快。通常，我们在处理用户登陆权限的问题中，就是使用redis来存储用户的session信息，它适合的典型场景就是：访问比较频繁的数据。 背景知识 http是一个无状态协议,由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了. 什么是session? session是一种服务器端的状态管理技术。 当浏览器访问服务器时，服务器创建一个session对象(该对象有一个唯一的id号，称之为sessionId),服务器在默认情况下，会将sessionId以cookie的方式(set-cookie消息头)发送给浏览器,浏览器会将sessionId保存到内存。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可找到之前创建的session对象。 客户端访问服务器端的流程： 首先，客户端会发送一个http请求到服务器端。 服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看Cookie详解Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure] 在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie。 服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端 cookie-session机制 用session只需要在客户端保存一个id（放在http头部携带的cookie中），实际上大量数据都是保存在服务端。 用cookie存储用户敏感信息session行不行？ 如果全部用cookie，数据量大的时候客户端是没有那么多空间的。账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。 并且客户端数据量变大，网络传输的数据量也会变大（每次http请求的头中都携带cookie信息） cookie-session机制 - 使用redis存储session 根据上面的介绍，大家应该明白了cookie-session来验证用户信息的机制，但是有人会问，既然你启动nodejs服务，他会启动一个进程，为什么要使用redis来存储session的信息，而不用nodejs进程的内存来存储？ 不同的操作系统会限制进程的内存大小（32位操作系统最大分给nodejs进程0.7G/64位操作系统为1.4G） 单个进程的内存有限，硬件的内存远大于此，资源浪费。 进程之间的数据是隔离的，而且一般线上环境都是多进程的。会造成系统异常。 redis（redis-server和redis-cli）启动redis-server redis-server 启动redis-cli redis-cli // 显示127.0.0.1：6379 nodejs中连接redis 1)安装启动redis npm i redis –save 2)读取配置建立redisClient 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /** * @description 连接redis的方法 * @author unclepis */const redis = require('redis')const &#123; redisConfig &#125; = require('../conf/db')// 创建redis客户端const redisClient = redis.createClient(redisConfig.port, redisConfig.host);redisClient.on('error', err =&gt; &#123; console.log('redis error', err)&#125;)// redis get/** * * @param &#123;string&#125; key key */let get = (key) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; redisClient.get(key, (err, val) =&gt; &#123; if(err) &#123; reject(err) return &#125; if(!val) &#123; resolve(null) return &#125; try &#123; resolve(JSON.parse(val)) // 尝试进行json转换 &#125; catch(error) &#123; resolve(val) &#125; &#125;) &#125;)&#125;//redis set/** * * @param &#123;string&#125; key key * @param &#123;*&#125; value value * @param &#123;*&#125; timeout 过期时间 单位是s */let set = (key, value, timeout = 60 * 60) =&gt; &#123; if(typeof value === 'object') &#123; value = JSON.stringify(value) &#125; redisClient.set(key, value) redisClient.expire(key, timeout)&#125;module.exports = &#123; get, set&#125; 在koa中使用redis存储session npm i koa-redis koa-generic-session --save 安装插件 app.js引入中间件 1234567891011121314151617181920212223 // 引入redis的配置 const &#123; redisConfig &#125; = require('./conf/db') const index = require('./routes/index') const users = require('./routes/users') // sessionId 进行加密处理app.keys = [redisConfig.salt]app.use(session(&#123; key: 'sessionId', // cookie中存储sessionId的名字，默认是koaId prefix: 'blog:sess:', // 在redis中对key增加一个前缀，默认是koa:sess: cookie: &#123; path: '/', httpOnly: true, // 不允许客户端修改 maxAge: 24 * 60 * 60 * 1000 // ms &#125;, ttl: 24 * 60 * 60 * 1000, //redis的过期时间，默认就是和cookie的过期时间一样 store: redisStore(&#123; all: `$&#123;redisConfig.host&#125;:$&#123;redisConfig.port&#125;` &#125;)&#125;)) 在路由中使用ctx.session 1234567891011router.get('/test', async (ctx, next) =&gt; &#123; const session = ctx.session; if(!session.viewNum) &#123; session.viewNum = 0 &#125; session.viewNum++; ctx.body = &#123; title: 'koa2 json', viewNum: session.viewNum &#125;&#125;) 可以看到/test的请求cookie中已经存在sessionId：xxxxx，而且在redis-cli中输入 keys * 也可以看到一个blog:sess:为前缀的key - blog:sess:xxxxxx，key的后半部分xxxxx和cookie中的xxxxx值一样。 在redis-cli中输入ttl可以查看redis的过期时间和cookie的过期时间也是差不多的(redis的过期时间为s，cookie为ms) 在登陆权限控制中的使用 在login登陆之后，可以将用户的信息，比如username存入redis中(ctx.username=username),然后同一个用户在请求后台的时候，就会从cookie中获取sessionId，查询redis中存储的username信息 就可以在中间件中，根据ctx.username是否存在判断用户是否登陆。有访问权限。 redis常用操作（持续补充） get key 获取数据 set key value 设置数据 keys * 所有的key列表 flushall 可以清除所有数据库的值 flushdb 清除当前数据库的值 exit 退出 参考文献彻底弄懂session，cookie，token]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelize - CRUD增删改查]]></title>
    <url>%2F2020%2F02%2F28%2Fsequelize-crud%2F</url>
    <content type="text"><![CDATA[介绍sequelize常用的crud方法:新增 create({创建的属性:属性的值}) 更新 update({需要更新的属性名称:需要更新的值},{where:{查询条件:值}) 删除 destroy({where:{查询条件:值}}) 查询 findOne({配置参数}) findAll({配置参数}) findAndCountAll({配置参数}) 123456789101112131415161718192021222324252627// &#123;配置参数&#125;&#123; attributes:['field'], // 自定义返回的列 where:&#123; id:1 // 指定查询条件 &#125;, where:&#123; username:&#123; [Op.like]:"%zhang%" // 模糊查询 &#125; &#125;, limit:10, // 查询多少条 offset:10, // 跳过多少开始 order:[ ["id","desc"] // 排序规则 ], include:[ // 联表查询 &#123; model:Blog, attributes:['filed1'], where:&#123; id:1 &#125; &#125; ], raw:true // 对sequelize数据格式处理，一般用于数据只显示的情况&#125; 新增 对创建的模型调用create方法 12345678910111213141516// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const createResult = ModalA.create(&#123; file1:value1, file2:value2, file3:value3, &#125;) // createResult.dataValues 可以获取到执行sql的数据结果 &#125;catch(error)&#123; console.error(error) &#125;&#125;)() 查询 对创建的模型调用findOne方法/findAll方法 查询一条记录 findOne 123456789101112131415161718192021// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const queryResult = ModalA.findOne(&#123; where:&#123; queryKey:queryValue, username: &#123; [Op.like]: "%zh%" // const Op = Sequelize.Op; 模糊查询 &#125; &#125;, raw:true // 就可以直接过去到返回的对象 &#125;) // queryResult 可以获取到执行sql的数据结果 &#125;catch(error)&#123; console.error(error) &#125;&#125;)() 查询特定的列 123456789101112131415161718// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const queryResult = ModalA.findOne(&#123; attributes:['column1','column2',...], // 需要返回的列 where:&#123; queryKey:queryValue &#125;, raw:true // 就可以直接过去到返回的对象 &#125;) // queryResult 可以获取到执行sql的数据结果 &#125;catch(error)&#123; console.error(error) &#125;&#125;)() 查询一个列表 - findAll 1234567891011121314151617181920// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const queryResults = ModalA.findAll(&#123; attributes:['column1','column2',...], // 需要返回的列 limit: 10, // 查询多少条 offset: 0, // 查询开始位置 orderBy:[ ["id","desc"] // 可以指定排序规则 ], raw:true // 就可以直接过去到返回的数组 &#125;) console.log(queryResults) &#125;catch(error)&#123; console.error(error) &#125;&#125;)() 查询带总数的列表 - findAndCountAll 12345678910111213141516171819202122// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const queryResults = ModalA.findAndCountAll(&#123; attributes:['column1','column2',...], // 需要返回的列 limit: 10, // 查询多少条 offset: 0, // 查询开始位置 orderBy:[ ["id","desc"] // 可以指定排序规则 ], raw:true // 就可以直接过去到返回的数组 &#125;) console.log('queryResults', queryResults.count, // 获取列表总数 queryResults.rows) // 列表的list数据 &#125;catch(error)&#123; console.error(error) &#125;&#125;)() 更新 update - 返回的是发生变更的数据条数，所以大于零就说明操作成功 123456789101112131415161718// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const updateResults = ModalA.update(&#123; attributeName:attributeValue &#125;,&#123; where:&#123; // 查询过滤参数 &#125; &#125;) console.log(updateResults) &#125;catch(error)&#123; console.error(error) &#125;&#125;)() 删除 destroy - 返回的是发生变更的数据条数，所以大于零就说明操作成功 123456789101112131415161718// 引入创建的模型const ModalA = require('.db/modal')// 新增数据!(async function()&#123; try&#123; const updateResults = ModalA.update(&#123; attributeName:attributeValue &#125;,&#123; where:&#123; // 查询过滤参数 &#125; &#125;) console.log(updateResults) &#125;catch(error)&#123; console.error(error) &#125;&#125;)()]]></content>
      <categories>
        <category>sequelize</category>
      </categories>
      <tags>
        <tag>sequelize - CRUD增删改查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelize - 数据建模以及数据同步]]></title>
    <url>%2F2020%2F02%2F28%2Fsequelize%2F</url>
    <content type="text"><![CDATA[在nodejs操作mySql数据库 中已经介绍了怎么使用nodejs链接mysql数据库，以及t通过Promise的方式封装了mysql执行sql获取数据，以及防止sql注入的escape方法。本章介绍orm数据关系映射 - Sequelize. ORM Object Relation Mapping 数据表，用js中的模型（class或者对象）代替 一条或多条记录，用对象或者数组代替 sql语句，使用对象的方法代替 (1) 安装mysql和sequelize npm i mysql2 sequelize –save (2) 配置sequelize建立数据库连接123456789101112131415161718const Sequelize = require('sequelize')// 引入mysql配置const &#123; mysqlConfig: &#123; database, username, password, host，dialect，pool &#125; &#125; = require('../conf/db')/** @params &#123;string&#125; - database 数据库名称* @params &#123;string&#125; - username 用户名* @params &#123;string&#125; - password 密码* @params &#123;Object&#125; - host主机地址，dialect数据库类型，pool连接池*/const seq = new Sequelize(database, username, password, &#123; host, dialect, pool // 线上环境需要使用连接池&#125;)module.exports = seq // 导出sequelize连接实例 (3)sequelize建模&amp;同步到数据库 之前nodejs直接连接mysql，需要在mysql中先建表，然后再nodejs中通过mysql的connect实例进行sql的查询。 sequelize通过数据建模，然后就会同步到数据库中生成响应的表，然后通过api的方式进行增删改查，以及多表查询等操作。 sequelize是通过define方法建立模型的，Model相当于数据库中的表，该对象不能通过构造函数实例化，而只能通过sequelize.define()或sequelize.import()方法创建 (3-1)创建数据模型 sequelize.define():define方法接收三个参数，第一个参数为表名称，第二个为所需要创建的数据库字段，第三个参数是相关表配置，具体配置参考文章结尾的连接 详细配置 更多阅读配置参数 Sequelize常用的数据类型，文章结尾有详细的列表 Sequelize.NOW - 获取当前时间 Sequelize.STRING Sequelize.INTEGER Sequelize.TEXT Sequelize.DATE Sequelize.DECIMAL 数据模型中的参数 type - Sequelize提供的类型 allowNull - true/false 是否为空 comment 备注信息 pattern 按照正则匹配 defaultValue 默认值 unique - true/false是否唯一 primaryKey - true/false 定义主键 autoIncrement - true/false 可用于创建自增的整数列 field - 属性指定自定义字段名称 12345678910111213141516171819202122 const Sequelize = require('sequelize') const seq = require('../seq') // 上面导出的sequelize连接实例// 跟建立User表一样，define的第一个参数就是表名，后面是表的列和属性 const User = req.define('user',&#123; // id 会自动创建，并设置为主键，自增 username:&#123; type:Sequelize.STRING, allowNull:false &#125;, password:&#123; type:Sequelize.STRING, allowNull:false &#125;, nickname:&#123; type:Sequelize.STRING &#125; &#125;) module.exports = &#123; User &#125; (3-2)创建数据表的外键 ModalA 多对一 ModalB123ModalA.belongsTo(ModalB,&#123; foreignKey:'ModalAForeignKeyName'&#125;) ModalB 一对多 ModalA123ModalB.hasMany(ModalA,&#123; foreignKey:'ModalAForeignKeyName'&#125;) 上面两种api二选一就行了，但是为了连表查询，所以都写比较好，查询ModalA带出来ModalB。必须写第一种写法。反之亦然。 (3-3)测试sequelize是否连接成功 - authenticate()方法12345678const seq = require('./seq') // 先导入sequelize连接实例// 测试sequelize链接是否成功seq.authenticate().then(() =&gt; &#123; console.log('sequelize connect successfully')&#125;).catch(err =&gt; &#123; console.log(err) console.log('sequelize connect failed')&#125;) (3-4)同步模型到数据库 - sync()方法 force: true 如果表已经存在，将会丢弃表 ; alter: true 如果表已存在，不丢弃，如果不存在会直接创建表 需要注意通过这种方式同步的表会在表名称后面添加一个s作为复数 会自动生成createdAt的创建时间，和修改时间updateAt,如果不需要这两个参数的话在define的第三个参数中修改表配置timestamps为false,默认为true 123456789const AaronTest = sequelize.define('project', &#123; title: Sequelize.STRING, description: &#123; type:Sequelize.txt, allowNull:false &#125;&#125;,&#123; timestamps: false // 不要添加时间戳属性 (updatedAt, createdAt)&#125;) force的意思是同步中存在的表会删掉，重新创建一个新的 同步成功需要手动退出进程process.exit() 会自动生成id，并且设置成主键，自动增加 1234567891011const seq = require('./seq') // 先导入sequelize连接实例require('/modal); // 导入创建的模型// 执行同步 seq.sync(&#123;force:true&#125;).then(() =&gt; &#123; process.exit(); // 同步成功需要手动退出进程 console.log('sequelize sync successfully')&#125;).catch(err =&gt; &#123; console.log(err) console.log('sequelize sync failed')&#125;) 在workbench中就可以看到数据表已经同步过来了。在Database=&gt;Reverse Engineer 就可以生成E-R实体关系图 补充文档 - 详细的模型参数和类型参数 Model definition - 模型定义如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const Foo = sequelize.define('foo', &#123; // 如果未赋值,则自动设置值为 TRUE flag: &#123; type: Sequelize.BOOLEAN, allowNull: false, defaultValue: true&#125;, // 设置默认时间为当前时间 myDate: &#123; type: Sequelize.DATE, defaultValue: Sequelize.NOW &#125;, // 将allowNull设置为false会将NOT NULL添加到列中， // 这意味着当列为空时执行查询时将从DB抛出错误。 // 如果要在查询DB之前检查值不为空，请查看下面的验证部分。 title: &#123; type: Sequelize.STRING, allowNull: false&#125;, // 创建具有相同值的两个对象将抛出一个错误。 唯一属性可以是布尔值或字符串。 // 如果为多个列提供相同的字符串，则它们将形成复合唯一键。 uniqueOne: &#123; type: Sequelize.STRING, unique: 'compositeIndex'&#125;, uniqueTwo: &#123; type: Sequelize.INTEGER, unique: 'compositeIndex'&#125;, // unique属性用来创建一个唯一约束。 someUnique: &#123;type: Sequelize.STRING, unique: true&#125;, // 这与在模型选项中创建索引完全相同。 &#123;someUnique: &#123;type: Sequelize.STRING&#125;&#125;, &#123;indexes: [&#123;unique: true, fields: ['someUnique']&#125;]&#125;, // primaryKey用于定义主键。 identifier: &#123; type: Sequelize.STRING, primaryKey: true&#125;, // autoIncrement可用于创建自增的整数列 incrementMe: &#123; type: Sequelize.INTEGER, autoIncrement: true &#125;, // 你可以通过'field'属性指定自定义字段名称： fieldWithUnderscores: &#123; type: Sequelize.STRING, field: 'field_with_underscores' &#125;, // 这可以创建一个外键: bar_id: &#123; type: Sequelize.INTEGER, references: &#123; // 这是引用另一个模型 model: Bar, // 这是引用模型的列名称 key: 'id', // 这声明什么时候检查外键约束。 仅限PostgreSQL。 deferrable: Sequelize.Deferrable.INITIALLY_IMMEDIATE &#125; &#125;&#125;) sequelize提供的几种数据类型，用于数据建模123456789101112131415161718192021222324252627282930Sequelize.STRING // VARCHAR(255) 类型：字符串 最大值： 65535个字符Sequelize.STRING(1234) // VARCHAR(1234) 类型：变长 最大值： 65535个字符Sequelize.TEXT // TEXT 类型：字符串 最大值：65535个字符Sequelize.TEXT('tiny') // TINYTEXT 类型：字符串 最大值：255个字符Sequelize.INTEGER // INTEGER 类型：整型 最大值：范围(-2147483648~2147483647)Sequelize.BIGINT // BIGINT 类型：整型 最大值：范围(+-9.22*10的18次方)Sequelize.BIGINT(11) // BIGINT(11) 类型：整型 最大值：范围(+-9.22*10的18次方)Sequelize.FLOAT // FLOAT 类型：单精度浮点型 8位精度(4字节)Sequelize.FLOAT(11) // FLOAT(11) 类型：单精度浮点型 8位精度(4字节)Sequelize.FLOAT(11, 12) // FLOAT(11,12) 类型：精度浮点型 8位精度(4字节) m总个数，d小数位Sequelize.DOUBLE // DOUBLE 类型：双精度浮点型 16位精度(8字节) Sequelize.DOUBLE(11) // DOUBLE(11) 类型：双精度浮点型 16位精度(8字节) Sequelize.DOUBLE(11, 12) // DOUBLE(11,12) 类型：双精度浮点型 16位精度(8字节) m总个数，d小数位Sequelize.DECIMAL // DECIMAL 类型：定点数型Sequelize.DECIMAL(10, 2) // DECIMAL(10,2) 类型：定点数型 参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位Sequelize.DATE // DATETIME 类型：日期时间类型 范例：'2009-05-12 02:31:44'Sequelize.DATE(6) // DATETIME(6) Sequelize.DATEONLY // DATE without time.Sequelize.BOOLEAN // TINYINT(1) 类型：整型 范围(-128~127)Sequelize.ENUM('value 1', 'value 2') // ENUM 类型：枚举Sequelize.BLOB // BLOB 类型：二进制数据Sequelize.BLOB('tiny') // TINYBLOB 类型：二进制数据 参考连接Sequelize 中文文档 v4 - Model definition - 模型定义 Sequelize 中 Model 的数据类型对应MySQL中的数据类型 Sequelize手记 - (一)]]></content>
      <categories>
        <category>sequelize</category>
      </categories>
      <tags>
        <tag>sequelize - 数据同步</tag>
        <tag>sequelize - 数据建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2开发后台服务 - (2) 服务端ssh之ejs模版]]></title>
    <url>%2F2020%2F02%2F27%2Fkoa2-ejs%2F</url>
    <content type="text"><![CDATA[ejs 简明教程现在主流的前端框架都是用了数据驱动和模版技术在渲染视图，最早的jsp和php都是通过服务器端渲染的方式进行页面的渲染，本章简单介绍一下koa-generator中生成的脚手架中使用的ejs的模版简单使用。 koa-view 通过在app.js文件中对koa-view中间件的使用，定义了路由中渲染的页面使用ejs模版中定义好/views的模板进行渲染 123app.use(views(__dirname + '/views', &#123;extension: 'ejs'&#125;)) 所以当路由中就可以使用ctx.render(&#39;模版名称&#39;,&quot;传递给模版的参数&quot;) 123456789101112131415router.get('/', async (ctx, next) =&gt; &#123;await ctx.render('index', &#123; greet: 'Hello Koa 2!', blogList:[ &#123; name:'docker简明教程'， author：“unclePis” &#125;, &#123; name:'ejs简明教程'， author：“auntCindy” &#125; ]&#125;)&#125;) ejs模版 - 变量 （&lt;%= %&gt;） 在ejs的模版中，使用html不需要包裹，使用js的时候，参数需要使用&lt;%= username %&gt;的方式进行包裹。 123&lt;p&gt; &lt;%= greet %&gt; //接受模版传递过来的greet参数渲染“Hello Koa 2!”&lt;/p&gt; ejs模版 - 表达式 （&lt;% %&gt;） 在ejs的模版中，使用html不需要包裹，使用js的时候，表达式需要使用&lt;% username %&gt;的方式进行包裹。 循环，类似react的jsx语法 12345&lt;ul&gt; &lt;% blogList.forEach(blog=&gt;&#123; %&gt; &lt;li&gt; &lt;%= blog.name %&gt; - &lt;span&gt; &lt;%= blog.author %&gt;&lt;/span&gt;&lt;/li&gt; &lt;% &#125;) %&gt;&lt;/ul&gt; if … else 逻辑判断 12345&lt;% if(!isMe)&#123; %&gt; &lt;a href="other person link"&gt;关注&lt;/a&gt;&lt;% &#125;else&#123; %&gt; &lt;button&gt;取消关注&lt;/button&gt;&lt;% &#125; %&gt; 组件化 可以把ejs抽离成片段，然后在需要的地方通过&lt;%- include(&#39;文件相对路径&#39;, {参数名：参数值}); %&gt; 12345&lt;ul&gt;&lt;% users.forEach(function(user)&#123; %&gt; &lt;%- include('user/show', &#123;user: user&#125;); %&gt;&lt;% &#125;); %&gt;&lt;/ul&gt; 12// ./user/show.ejs&lt;li&gt; &lt;%= user %&gt;&lt;/li&gt; // 这样就会获取到上面传递的user参数 总结 暂时用到的就这么多，当然还有很多别的用法后续慢慢用到再补充： 变量 - &lt;%= variable %&gt; 表达式 - &lt;% expression %&gt; 组件 - &lt;%- include(‘相对路径’，传递的参数) %&gt;]]></content>
      <categories>
        <category>ejs</category>
      </categories>
      <tags>
        <tag>ejs</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2开发后台服务 - (1) 项目开发环境搭建]]></title>
    <url>%2F2020%2F02%2F27%2Fkoa2%2F</url>
    <content type="text"><![CDATA[初始化项目第一部分 ：使用koa-generator脚手架生成项目 全局安装安装koa-generator npm install koa-generator -g 使用koa2 生成一个使用ejs为服务器端模板的项目，koa2-demo koa2 -e koa2-demo 进入项目 cd koa2-demo 初始化git仓库并添加gitignore git init 初始化项目 touch .gitignore新建文件，然后添加node_modules和dist目录为忽略git跟踪的目录，其他的后续补充 调整工程初始化项目结构 将public目录，routes目录和views目录,以及app.js都移动到新增的src目录下管理源代码 修改项目中需要加载的文件 12// src/bin/wwwvar app = require('../src/app'); 安装插件(持续补充) 默认的插件都是koa-generator自动生成的 1234567891011121314151617dependencies": &#123; "debug": "^4.1.1", // 可以理解成是高级的console "ejs": "~2.3.3", // 服务端ssr模板 "koa": "^2.7.0", // koa "koa-bodyparser": "^4.2.1", // 解析http的body参数(支持json,form,text类型) "koa-convert": "^1.2.0", "koa-json": "^2.0.2",// 美观的输出JSON response的Koa中间件 "koa-logger": "^3.2.0", // koa日志 "koa-onerror": "^4.1.0",// koa有error事件，当发生错误，可以通过error事件，对错误统一处理 "koa-router": "^7.4.0", // koa路由 "koa-static": "^5.0.0", // 用于koa的静态文件指定映射路径。 "koa-views": "^6.2.0" // 用于指定视图的渲染模板类型 &#125;, "devDependencies": &#123; "cross-env": "^7.0.0", // 支持跨平台环境变量设置 "nodemon": "^1.19.1" // node monitor 支持文件变化热部署 &#125; 安装cross-env到devDependency下，支持跨平台设置环境变量 1npm i cross-env --save-dev 修改package.json文件 修改npm脚本,设置dev和prd的环境变量参数 12"dev": "cross-env NODE_ENV = dev ./node_modules/.bin/nodemon bin/www","prd": "cross-env NODE_ENV = production pm2 start bin/www", 运行项目npm run dev 如果项目没有报错，并且已经可以加载路由，说明配置没有问题了。 初始化README.md，git本地提交修改，配置远程仓库地址，推送代码到远程仓库 git add . ;git commit -m&quot; init project&quot;; git remote add origin xxxxx; 设置远程仓库地址xxxxx git remote -v 可以查看是否配置完成远程仓库和本地仓库的映射 git branch --set-upstream-to=origin/master master 设置git pull的时候仓库映射本地master对应远程master git push origin master -u; 到这里，项目就初始化完成。补充 (持续更新) 1）git提交记录规则(可以安装插件规范git的commit格式) 1234567feat: 新功能 (feature)fix: 修补bugdocs: 补充文档ref: 重构代码 (refactor)chore: 一些配置的变动style: ui，样式调整test: 测试内容 可以通过git log --grep=&quot;feat&quot;对日志进行过滤查找。 2) 使用jsdoc /** 回车就可以引入jsdoc 新增文件的时候，引入@description和@author，简述文件时干什么的，谁写的。 对函数写清楚变量类型和参数以及变量含义，一方面方便看的人理解，再就是在引用的地方会智能提醒。 123456789/*** * @param &#123;string&#125; key key* @param &#123;*&#125; value value* @param &#123;*&#125; timeout 过期时间 单位是s*/let setRedis = (key,value,timeout)=&gt;&#123; // todo&#125; 参考链接第一部分参看文章 - koa中间件记录]]></content>
      <categories>
        <category>nodeJs</category>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs - Crypto模块]]></title>
    <url>%2F2020%2F02%2F27%2Fnodejs-8%2F</url>
    <content type="text"><![CDATA[简介加密 加密是以某种算法改变原有的信息数据，使得未授权用户即使获得了已加密信息，因不知解密的方法，无法得知信息真正的含义通过这种方式提高网络数据传输的安全性. 加密算法常见的有一下五类: 哈希算法 HMAC 算法 签名、 对称性加密算法 非对称性加密算法 加密算法也分为可逆和不可逆，比如 md5 就是不可逆加密，只能暴力破解（撞库），node利用 OpenSSL库来实现它的加密技术，crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装，核心模块，使用时不需安装。 第一类 - hash算法/哈希算法/散列算法 用来把任意长度的输入变换成固定长度的输出 常见的有 md5、sha1,还有例如sha256，sha512，ripemd160-crypto.getHashes()方法用于查看支持的加密算法 md5 - 也叫’摘要算法’ 具有以下几个特点 不可逆； 不管加密的内容多长，最后输出的结果长度都是相等的； 内容不同输出的结果完全不同，内容相同输出的结果完全相同 暴力破解 由于相同的输入经过 md5 加密后返回的结果完全相同，所以破解时通过 “撞库” 进行暴力破解，当连续被 md5 加密 3 次以上时就很难被破解了，所以使用 md5 一般会进行多次加密 使用 1234let md5 = crytpo.createHash("md5"); // 创建 md5let md5Sum = md5.update("123"); // update 加密let result = md5Sum.digest(); // 获取加密后结果// result &lt;Buffer 20 2c b9 62 ac 59 07 5b 96 4b 07 15 2d 23 4b 70&gt; update方法的返回值就是 this，即当前实例，所以支持链式调用，较长的信息也可以多次调用 update 方法进行分段加密，调用 digest 方法同样会返回整个加密后的值 12345crypto .createHash("md5") .update("admin") .update("123") .digest("hex"); // 0192023a7bbd73250516f069df18b500 digest 方法参数用于指定加密后的返回值的格式,不传参默认返回加密后的 Buffer，常用的参数有 hex 和 Base64，hex 代表十六进制，加密后长度为 32，Base64 的结果长度为 24，以 == 结尾 12crypto.createHash('md5').update('123').digest('hex') // 202cb962ac59075b964b07152d234b70crypto.createHash('md5').update('123').digest('base64')//'ICy5YqxZB1uWSwcVLSNLcA==' 第二类 Hmac 算法 - 也叫加盐算法 是将哈希算法与一个密钥结合在一起，用来阻止对签名完整性的破坏，同样具备 md5 加密的几个特点。 使用 1crypto.createHmac("sha1", "salt").update('admin123').digest('hex'); // 629a619b75bd12ecb66a749558ba5b4f9703d531 createHmac(‘加密的算法’,’密钥’) - 第一个参数同 crytpo.createHash,为加密的算法，常用 sha1 和 sha256，第二个参数为密钥 digest 方法生成的加密结果长度要大于 md5(因为Hmac算法常用 sha1 和 sha256)，hex 生成的结果长度为 64，Base64 生成的结果长度为 44，以 = 结尾 创建密钥的方法 可以安装 openSSH 客户端，并通过命令行生成存储密钥的文件，命令如下。 openssl genrsa -out rsa_private.key 1024 openssl genrsa 代表生成密钥，-out 代表输出文件，rsa_private.key 代表文件名，1024 代表输出密钥的大小 12345678// 直接读取密钥文件配合加盐算法加密const fs = require("fs");const crypto = require("crypto");const path = require("path");let key = fs.readFileSync(path.join(__dirname, "/rsa_private.key"));let hmac = crypto.createHmac("sha256", key);let result = hmac.update("admin123").digest("Base64"); 第三类 对称性加密 对称性加密是发送数据时使用密钥和加密算法进行加密，接收数据时需要使用相同的密钥和加密算法的逆算法（解密算法）进行解密，也就是说对称性加密的过程是可逆的，crypto 中使用的算法为 blowfish 使用 123456789101112131415161718192021// 对称性加密const fs = require("fs");const crypto = require("crypto");const path = require("path");let key = fs.readFileSync(path.join(__dirname, "/rsa_private.key"));// 加密let cipher = crypto.createCipher("blowfish", key);cipher.update("admin123");// final 方法不能链式调用let result = cipher.final("hex");console.log(result); // 7c827dbc0b9ccc4d// 解密let decipher = crypto.createDecipher("blowfish", key);decipher.update(result, "hex");let data = decipher.final("utf8");console.log(data); // admin123 加密使用 crypto.createCipher 方法，解密使用 crypto.createDecipher 方法，但是使用的算法和密钥必须相同，需要注意的是解密过程中 update 中需要在第二个参数中指定加密时的格式，如 hex，在 final 还原数据时需要指定加密字符的编码格式，如 utf8。 第四类 非对称性加密 非对称性加密相也是可逆的，较于对称性加密要更安全，消息传输方和接收方都会在本地创建一对密钥，公钥和私钥，互相将自己的公钥发送给对方，每次消息传递时使用对方的公钥加密，对方接收消息后使用他的私钥解密，这样在公钥传递的过程中被截获也无法解密，因为公钥加密的消息只有配对的私钥可以解密。 使用 openSSH 对之前生成的私钥 rsa_private.key 产生一个对应的公钥 openssl rsa -in rsa_private.key -pubout -out rsa_public.key 上面的命令意思根据一个私钥生成对应的公钥，-pubout -out 代表公钥输出，rsa_public.key 为公钥的文件名 12345678910111213141516// 非对称性加密const fs = require("fs");const crypto = require("crypto");const path = require("path");// 获取公钥和私钥let publicKey = fs.readFileSync(path.join(__dirname, "/rsa_public.key"));let privateKey = fs.readFileSync(path.join(__dirname, "/rsa_private.key"));// 加密let secret = crypto.publicEncrypt(publicKey, Buffer.from("hello"));// 解密let result = crypto.privateDecrypt(privateKey, secret);console.log(result); // hello 使用公钥加密的方法是 crypto.publicEncrypt，第一个参数为公钥，第二个参数为加密信息（必须是 Buffer），使用私钥解密的方法是 crypto.privateDecrypt，第一个参数为私钥，第二个参数为解密的信息。 签名 签名与非对称性加密非常类似，同样有公钥和私钥，不同的是使用私钥加密，对方使用公钥进行解密验证，以确保这段数据是私钥的拥有者所发出的原始数据，且在网络中的传输过程中未被修改。 使用 1234567891011121314151617181920// 签名const fs = require("fs");const crypto = require("crypto");const path = require("path");// 获取公钥和私钥let publicKey = fs.readFileSync(path.join(__dirname, "rsa_public.key"), "ascii");let privateKey = fs.readFileSync(path.join(__dirname, "rsa_private.key"), "ascii");// 生成签名let sign = crypto.createSign("RSA-SHA256");sign.update("admin123");let signed = sign.sign(privateKey, "hex");// 验证签名let verify = crypto.createVerify("RSA-SHA256");verify.update("admin123");let verifyResult = verify.verify(publicKey, signed, "hex");console.log(verifyResult); // true 生成签名的 sign 方法有两个参数，第一个参数为私钥，第二个参数为生成签名的格式，最后返回的 signed 为生成的签名（字符串）。 验证签名的 verify 方法有三个参数，第一个参数为公钥，第二个参数为被验证的签名，第三个参数为生成签名时的格式，返回为布尔值，即是否通过验证。 总结 createHash - 哈希算法，常用md5的方式，还有sha1,sha256等，不可逆，加密源数据一样生成的结果一样，长度固定。 createHmac - 用随机数“增强”的哈希算法，加salt，常用sha1,sha256等方式加密。 对称性加密 - 使用相同的密钥进行加密和解密处理 非对称性加密 - 双方都生成一对公钥和私钥，APublic,APrivate,BPublic，BPrivate,将自己的公钥都给对方，然后传输前使用对方的公钥加密，使用自己的私钥进行解密 签名 - 使用私钥进行加密，然后传输，最后通过公钥进行解密 参考文献NodeJS 加密 —— crypto 模块密码安全性策略]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
      <tags>
        <tag>nodeJs</tag>
        <tag>Crypto</tag>
        <tag>md5</tag>
        <tag>对称加密</tag>
        <tag>非对称加密</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+gitlab/coding 搭建个人blog]]></title>
    <url>%2F2020%2F02%2F25%2Fhexo%2F</url>
    <content type="text"><![CDATA[基于hexo搭建私人的blog 最近在项目组内使用hexo和gitlab/coding帮助小组内部搭建了一个“组内学习blog”，一方面帮助大家把每周分享的技术资料管理起来，一方面通过hexo搭建的静态网站也方便查看和回顾，下面准备将整个搭建过程记录下来. 步骤1:全局安装hexohexo是一个轻量级的博客框架，它是给予markdown的，可以快速搭建一个静态网站 12npm install hexo -g // 国内推荐使用taobao的镜像仓库，cnpm install hexo -ghexo -v // 查看hexo是否安装成功 步骤2:建立blog文件夹，快速初始化项目123mkdir blogName // 在准备创建项目的目录下通过命令行创建一个文件夹blogNamecd blogName // 进入blogNamehexo init // 使用hexo快速初始化一个基本的blog系统 步骤3:本地运行blog1hexo server // hexo s 也可以在本地http://localhost:4000拉起整个blog 步骤4:blog的基本配置主题风格 hexo默认是使用landscape主题，如果需要其他主题，例如Next,yilia都是比较常用的主题,在hexo项目的根路径下执行下面的命令从github下载相应的主题包 123git clone https://github.com/iissnan/hexo-theme-next themes/next // 从github下载Next主题git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia // 从github上下载yilia主题 如果是多人合作的blog项目推荐使用git submodule add xxx.git 的方式将主体包当作子模块引入，而不是直接clone在hexo的工程中，有一个全局配置的_config.yml文件和主题的配置的_config.yml文件 在主题配置中找到theme，可以选择主题风格,123456789# theme: landscapetheme: next #主题拓展，可以在主题商店选择其他主题，这里使用next # theme: yilia# Schemes # NexT 主题提供三种布局#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 添加blog的菜单栏在主题配置中找到menu 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 注意每个主题风格下的menu写法略有不同，在Next主题下上，menu下面的菜单栏分别表示菜单文件的路径(例如/tags))和图标(tags) 配置好menu的配置后需要创建相关的文件 1hexo new page xxx // 例如创建tags的menu，则是hexo new page tags,则会在source路径下创建tags文件夹 给md文件引入image图片在全局配置_config.yml文件中修改如下属性 1post_asset_folder: true #创建同名的folder引入图片到md文件 安装hexo-asset-image插件在md文件中引入图片 1npm install hexo-asset-image --save 当执行 hexo new xxx 命令的时候，会在source路径下创建xxx.md文件和同名的xxx文件夹，用来存放image等附件 对blog进行分类管理一般一个md文件的文章只能有一个categories使用： hexo new page categories 新建一个 标签 页面。 对source／tags/index.md增加type:”tags”12345---title: tagsdate: 2018-10-14 17:27:15type: "tags"--- 在source的xxx.md文件中 12345---title: 标签测试categories:- Testing （这个就是文章的分类了）--- 对blog进行标签管理一般一个md文件的文章可以you多个tags使用： hexo new page tags 新建一个 标签 页面。对source／categories/index.md增加type:”categories” 12345---title: tagsdate: 2018-10-14 17:27:15type: "tags"--- 在source的xxx.md文件中 123456---title: 标签测试tags:- Testing （这个就是文章的标签了）- Another Tag （这个就是文章的标签了）--- 对blog进行全局搜索step1 :安装插件直接在博客文件夹下运行命令 1npm install hexo-generator-searchdb --save step2:修改站点全局配置文件_config.yml 12345search：path: search.xmlfield: postformat: htmllimit: 10000 step3:修改主题配置文件_config.yml 12local_search: enable: true 注册gitlab仓库和coding仓库地址 为了让国内和国外的用户都可以访问你的blog，所以最好同步发布到gitlab和coding，提高用户的访问速度 创建一个远程仓库的地址 xxx.git配置git 123git config --global user.name &quot;Pis&quot; git config --global user.email &quot;email@xxx.com&quot;git config --list //查看git配置 ssh私钥本地Git仓库和代码托管远程仓库之间的传输是通过SSH加密的 123456 ssh-keygen -t rsa -C &quot;email@xxx.com&quot; ＃创建SSH Key 1&gt;如果在用户主目录下有.ssh目录，查看有没有id_rsa和id_rsa.pub这两个文件2&gt;没有的话，执行ssh-keygen -t rsa -C &quot;email@example.com&quot;，按照向导填写信息。3&gt;id_rsa是私钥，不能泄漏出去；id_rsa.pub是公钥，可以放心的告诉别人。4&gt;登陆远程托管仓库，在settings中SSH_Keys页面点击Add SSH Key，填上title在key文本里面粘贴id_rsa.pub文件的内容。 远程仓库和本地blog项目建立关系12git remote add origin xxx.git //将本地的blog项目和远程的xxx.git仓库的master分支建立关系git remote -v // 可以查看是否建立了关系 在全局配置中找到URL配置项，配置hexo最终部署的地址如果本地样式显示正常，deploy部署到远程环境样式异常，一般都是url配置的不对12345# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'# 一般填写自己的站点链接url: http://unclepis.coding.meroot: / 12345deploy: type: git repo: coding: coding远程仓库地址,coding远程仓库分支 gitlab: gitlab远程仓库地址,gitlab远程仓库分支 配置好这个后执行 1hexo d -g //就会发布blog项目到远程的代码仓库 部署完成以后就可以通过coding或者gitlab的pages服务，通过url访问blog了其他配置hexo的next主题个性化教程:打造炫酷网站Hexo个人博客SEO优化——如何被百度谷歌收录怎么进行百度验证（html标签验证&amp;文件验证）hexo插件）hexo加密文章配置hexo新建文章置顶]]></content>
      <categories>
        <category>博客搭建</category>
        <category>hexo+gitlab/coding 搭建个人blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>gitlab</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步操作]]></title>
    <url>%2F2020%2F02%2F25%2Fasync%2F</url>
    <content type="text"><![CDATA[javascript是一个单线程执行的语言，所以在处理阻塞io是通过异步回调的方式进行，常用的处理异步的方式有以下几种： [✔] callback hell回调地狱[✔] promise[✔] generator[✔] async await 本章先介绍一下 promise的基本语法和使用细节… 链式调用 异常捕获 then方法第二个参数获取的错误信息和catch不会异常的区别 finally方法的使用 Promise.all方法的使用 promise.race方法的使用 ES2020关于promise的新特性 - Promise.allSettled方法 Promise基本概念 Promise有两个参数，resolve和reject resolve：将异步的执行从pending(请求)变成了resolve(成功返回)，是个函数执行返回 reject：顾名思义“拒绝”，就是从请求变成了”失败”，是个函数可以执行返回一个结果 示例说明 假设有以下三个文件 1234567891011121314151617// 1.json &#123; "next": "2.json", "message":"this is first File, hello" &#125;// 2.json &#123; "next": "3.json", "message":"this is second File" &#125;// 3.json &#123; "next": null, "message":"this is third File, good bye" &#125; 使用nodejs的fs模块读取一下文件模拟异步 （1）不使用promise,callbackHell回调地狱的方式123456789101112131415161718192021222324252627282930/** * 不使用promise,callback hell * @param &#123;*&#125; fileName */fs.readFile(path.resolve(__dirname, '1.json'), (error, file1) =&gt; &#123; if(error) &#123; console.log(error) return &#125; console.log(JSON.parse(file1.toString()).message) // 成功读取第一个文件后，读取下一个文件 fs.readFile(path.resolve(__dirname, JSON.parse(file1.toString()).next), (error, file2) =&gt; &#123; if(error) &#123; console.log(error) return &#125; console.log(JSON.parse(file2.toString()).message) // 成功读取第二个文件后，读取下一个文件 fs.readFile(path.resolve(__dirname, JSON.parse(file2.toString()).next), (error, file3) =&gt; &#123; if(error) &#123; console.log(error) return &#125; console.log(JSON.parse(file3.toString()).message) &#125;) &#125;)&#125;) 可以看到，我们在读取第一个文件1.json的回调函数里面，根据file1的读取结果中的next，获取需要读取的下一个文件。如果继续有多个文件需要读取，代码可读性非常差。层级结构特别复杂。 （2）promise的方式123456789101112131415/** * 使用promise封装fs读取文件的异步操作 * @param &#123;*&#125; fileName - 文件名 */const readFile = (fileName) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path.resolve(__dirname, fileName), (error, result) =&gt; &#123; if(error) &#123; reject(error) return &#125; resolve(JSON.parse(result.toString())) &#125;) &#125;)&#125; 链式调用（错误的写法，不推荐这样写，跟回调地狱一样不太友好） 123456789101112 /*** promise链式调用*/ readFile('1.json').then(file1 =&gt; &#123; console.log('file1', file1) readFile(file1.next).then(file2 =&gt; &#123; console.log('file2', file2) readFile(file2.next).then(file3 =&gt; &#123; console.log('file3', file3) &#125;) &#125;) &#125;) 这样通过promise的then方法进行链式调用，但是还是存在层级嵌套，代码可读性还是不够友好。 链式调用（正确的写法） then式链式写法的本质其实是一直往下传递返回一个新的Promise，也就是说then在下一步接收的是上一步返回的Promise 123456789101112 /*** promise链式调用*/ readFile('1.json').then(file1 =&gt; &#123; console.log('file1', file1) return readFile(file1.next) &#125;).then(file2 =&gt; &#123; console.log('file2', file2) return readFile(file2.next) &#125;).then(file3 =&gt; &#123; console.log('file3', file3) &#125;) 上面这样通过将promise进行return的方式，就可以在then里面获取到promise的结果，进行链式调用，而且代码看起来像是同步执行的代码，可读性好，没有了多层嵌套的回调地狱. 异常捕获 可以看到上面的Promise已经通过链式调用的方式，一次读取了三个文件，但是在这其中发生异常的时候，我们常做的处理有以下两种： 通过Promise的catch方法进行捕获(Promise抛错具有冒泡机制，能够不断传递，可以使用catch统一处理) Promise.then第二个参数捕获错误，回调参数捕获错误具有就近的原则，不会影响后续then的进行 区别就是： catch写法是针对于整个链式写法的错误捕获的，而then第二个参数是针对于上一个返回Promise的两者的优先级： catch的位置很有讲究,就是看谁在链式写法的前面，在前面的先捕获到错误，后面就没有错误可以捕获了，链式前面的优先级大，而且两者都不是break， 可以继续执行后续操作不受影响1234567891011readFile('1.json').then(file1 =&gt; &#123; console.log(file1) return readFile('2.json')&#125;).then(file2 =&gt; &#123; console.log(file2) return Promise.reject(new Error('模拟错误'))&#125;).catch(err =&gt; &#123; // 把catch写在两个then之间，当catch住前面then的异常，下面的then可以继续执行 console.log(err)&#125;).then(info =&gt; &#123; console.log('上面catch报错了，下面的then也执行')&#125;) 需要注意的地方就是： catch会一次性捕获所有then里面发生的异常,当catch前面的then发生异常，其他then就不执行了，直接进catch;但是catch后面的then可以继续执行。 then的第二个参数error，会单独捕获then里面的异常（捕获错误具有就近的原则），并且不会阻塞代码继续执行下面的then 通常的做法就是： 只需要在末尾catch一下就可以了，因为链式写法的错误处理具有“冒泡”特性，链式中任何一个环节出问题，都会被catch到，同时在某个环节后面的代码就不会执行了。 1234567891011121314151617readFile('1.json').then(file1 =&gt; &#123; console.log('file1', file1) return readFile(file1.next)&#125;, error =&gt; &#123; console.log('file1Error', error) // 当执行第一个then报错了，会在这里打印，但是下面的then会继续执行&#125;).then(file2 =&gt; &#123; console.log('file2', file2) return readFile(file2.next)&#125;, error =&gt; &#123; console.log('file2Error', error) // 当执行第二个then报错了，会在这里打印，但是下面的then会继续执行&#125;).then(file3 =&gt; &#123; console.log('file3', file3)&#125;, error =&gt; &#123; console.log('file3Error', error) // 当执行第一个then报错了，会在这里打印，但是下面的catch方法不会执行&#125;).catch(err =&gt; &#123; console.log('promise catch error', err) // &#125;) finally finally() 方法返回一个Promise，在promise执行结束时，无论结果是fulfilled或者是rejected，在执行then()和catch()后，都会执行finally指定的回调函数。这为指定执行完promise后，无论结果是fulfilled还是rejected都需要执行的代码提供了一种方式，避免同样的语句需要在then()和catch()中各写一次的情况。 常用的方式就是then-catch-finally 12345678910111213readFile('1.json').then(file1 =&gt; &#123; console.log('file1', file1) return readFile(file1.next)&#125;).then(file2 =&gt; &#123; console.log('file2', file2) return readFile(file2.next)&#125;).then(file3 =&gt; &#123; console.log('file3', file3)&#125;).catch(err =&gt; &#123; console.log('promise catch error', err)&#125;).finally(()=&gt;&#123; console.log('all files has been read')&#125;) 如果需要分开捕获异常就单独使用then的第二个error参数，不影响finally 1234567891011121314151617 readFile('1.json').then(file1 =&gt; &#123; console.log('file1', file1) return readFile(file1.next)&#125;, error =&gt; &#123; console.log('file1Error', error) // 当执行第一个then报错了，会在这里打印，但是下面的then会继续执行&#125;).then(file2 =&gt; &#123; console.log('file2', file2) return readFile(file2.next)&#125;, error =&gt; &#123; console.log('file2Error', error) // 当执行第二个then报错了，会在这里打印，但是下面的then会继续执行&#125;).then(file3 =&gt; &#123; console.log('file3', file3)&#125;, error =&gt; &#123; console.log('file3Error', error) // 当执行第一个then报错了，会在这里打印&#125;).finally(()=&gt;&#123; console.log('all files has been read')&#125;) Promise.all静态方法 - promise并行执行 Promise.all的成功结果是返回一个数组，且数组中数据的结果顺序与Promise.all数组的传参顺序是一样的。 12345678Promise.all( [ readFile('1.json'), readFile('2.json'), readFile('3.json')]).then(result =&gt; &#123; console.log(result) // 当三个文件都读取完成进入then的回调中&#125;) Promise.race静态方法 - promise率先执行 Promise.race只要其中一个实例率先发生改变，Promise.race实例也将发生改变，其他的将不在响应. 12345678Promise.race( [ readFile('1.json'), readFile('2.json'), readFile('3.json')]).then(result =&gt; &#123; console.log(result) // 当一个文件先读取完成，其他的不响应&#125;) Promise.allSettled - Promise执行多个请求有异常的时候不阻塞其他执行 Promise.all如果参数中的任何一个promise为reject的话，则整个Promise.all 调用会立即终止，并返回一个reject的新的 Promise 对象。 Promise.allSettled它不会进行短路，也就是说当Promise全部处理完成后，我们可以拿到每个Promise的状态，而不管是否处理成功 12345678Promise.allSettled( [ Promise.reject(&#123; code: 500, msg: '服务异常' &#125;), readFile('2.json'), readFile('3.json')]).then(result =&gt; &#123; console.log(result) // 当一个文件先读取完成，其他的不响应&#125;) 结果 1234567891011[ &#123; status: 'rejected', reason: &#123; code: 500, msg: '服务异常' &#125; &#125;, &#123; status: 'fulfilled', value: &#123; next: '3.json', message: 'this is second File' &#125; &#125;, &#123; status: 'fulfilled', value: &#123; next: null, message: 'this is third File, good bye' &#125; &#125;] 参考链接nodejs中的promise基本操作Promise异步Promise及Async/Await可能最完整入门攻略]]></content>
      <categories>
        <category>js异步操作</category>
      </categories>
      <tags>
        <tag>callback hell</tag>
        <tag>回调地狱</tag>
        <tag>promise</tag>
        <tag>async await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（10）- vue面试指南]]></title>
    <url>%2F2020%2F02%2F24%2Fvue-10%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（10）主要收录的就是vue的面试汇总，后面也会持续补充…都是一些基础的概念,只记录自己感觉重要的 组件通信相关1）组件通信的方式有哪些？组件通信的六种方式 2）子组件为什么不可以修改父组件传递的Prop？ Vue提倡单向数据流,即父级 props 的更新会流向子组件,但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高 3）v-model是如何实现双向绑定的？ 他的本质是 v-bind 和 v-on 的语法糖，在一个组件上使用 v-model，默认会为组件绑定名为 value 的 prop 和名为 input 的事件 周期函数相关1）vue组件有哪些声明周期钩子？ beforeCreate、 created、 beforeMount、 mounted、 beforeUpdate、 updated、 beforeDestroy、 destroyed。 有自己独立的钩子函数： activated deactivated。 2）Vue 的父组件和子组件生命周期钩子执行顺序是什么？ 渲染过程：父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的mounted在子组件mounted之后 父beforeCreate -&gt; 父created -&gt; 父beforeMount -&gt; 子beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt; 子mounted -&gt; 父mounted 子组件更新过程： 影响到父组件：父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted不影响父组件：子beforeUpdate -&gt; 子updated 父组件更新过程： 影响到子组件：父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted不影响子组件：父beforeUpdate -&gt; 父updated 销毁过程：父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed 看起来很多好像很难记忆，其实只要理解了，不管是哪种情况，都一定是父组件等待子组件完成后，才会执行自己对应完成的钩子，就可以很容易记住。 配置属性相关1）v-show 和 v-if 有哪些区别？ v-if 会在切换过程中对条件块的事件监听器和子组件进行销毁和重建，如果初始条件是false，则什么都不做，直到条件第一次为true时才开始渲染模块。v-show 只是基于css进行切换，不管初始条件是什么，都会渲染。 v-if 切换的开销更大，而 v-show 初始化渲染开销更大，在需要频繁切换，或者切换的部分dom很复杂时，使用 v-show 更合适。渲染后很少切换的则使用 v-if 更合适。 2）computed ，watch，methods 有什么区别？ computed 计算属性，是依赖其他属性的计算值，并且有缓存，只有当依赖的值变化时才会更新，适合多个属性变化的检测。 watch 是在监听的属性发生变化时，在回调中执行一些逻辑。适合监听单个属性的变化，当然可以是一个引用类型 methods每次都会执行相应的方法,没有缓存。 3）keep-alive 的作用是什么？ 可以在组件切换时，保存其包裹的组件的状态，使其不被销毁，防止多次渲染。其拥有两个独立的生命周期钩子函数 actived 和 deactived，使用 keep-alive 包裹的组件在切换时不会被销毁，而是缓存到内存中并执行 deactived 钩子函数，命中缓存渲染后会执行 actived 钩子函数 4）Vue 中 v-html 会导致什么问题？ 在网站上动态渲染任意 HTML，很容易导致 XSS 攻击。所以只能在可信内容上使用 v-html，且永远不能用于用户提交的内容上 5）v-for 中 key 的作用是什么？ key 是给每个 vnode 指定的唯一 id，在同级的 vnode diff 过程中，可以根据 key 快速的对比，来判断是否为相同节点，并且利用 key 的唯一性可以生成 map 来更快的获取相应的节点。另外指定 key 后，就不再采用“就地复用”策略了，可以保证渲染的准确性。 6) 为什么 v-for 和 v-if 不建议用在一起? 当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费 7) 组件的 data 为什么要写成函数形式? Vue 的组件都是可复用的，一个组件创建好后，可以在多个地方复用，而不管复用多少次，组件内的 data 都应该是相互隔离，互不影响的，所以组件每复用一次，data 就应该复用一次，每一处复用组件的 data 改变应该对其他复用组件的数据不影响。为了实现这样的效果，data 就不能是单纯的对象，而是以一个函数返回值的形式，所以每个组件实例可以维护独立的数据拷贝，不会相互影响 路由相关问题Vue-router 导航守卫有哪些? 全局前置/钩子：beforeEach、beforeResolve、afterEach 路由独享的守卫：beforeEnter 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave 参考链接赤果果的借鉴😄，在这个基础上补充]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（10）- vue面试指南</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（10）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs自动打包构建工具替代Jekins(1) - linux命令基础]]></title>
    <url>%2F2020%2F02%2F20%2Fautodeploy%2F</url>
    <content type="text"><![CDATA[之前在水牛下水系列（0）- linuxDeploy 基础及其服务器nginx静态资源部署写过在项目上部署一个前端工程的基本流程[🦶] npm run build通过打包工具将前端工程打包成静态资源到置顶的目录[🦶] 手动对静态资源目录dist和nginx等项目部署的配置文件进行压缩[🦶] 通过ssh工具上传静态资源到服务器的指定目录下[🦶] 备份上一个版本的静态资源目录[🦶] 将新的静态资源目录放到nginx服务目录下，并修改nginx配置文件[🦶] 重启nginx服务 这么一个手动部署应用的过程，在项目中已经使用jekins在代码仓库gitlab中配置了git hook，当master分钟有代码的push，就会触发Jekins执行上面一系列的操作将项目代码部署到服务器上…前阵子无意间刚好看到一个哥们用nodejs实现了这一些列的功能，改吧改吧准备在项目上试试，也顺便看看如何通过nodejs实现这一些列的操作。 linux基础因为上述devOps的流程中牵扯了一系列命令行操作 执行npm run build 打包的npm脚本 使用tar命令压缩dist目录 node-ssh连接ssh服务器上传dist已经nginx配置文件 复制文件到指定目录/备份文件 重启nginx所以打算先看看一些linux下常用的命令，后面有的会用到，其他的也就复习一下… cat命令[格式] cat &lt;文件名&gt;[&gt;或者&gt;&gt;]&lt;文件名&gt;[1] cat existFilename - 查看已经存在的文件内容[2] cat existFile1 existFile2 &gt; targetFile - 把已经存在的文件复制到目标文件中[3] cat existFile &gt;&gt; targetFile - 把已经存在的文件追加到目标文件中[4] cat &gt;&gt; targetFile &lt; targetFile &lt;&lt;Signature Signature - 将两个Signature之间的内容写入到目标文件 echo命令[格式] echo &lt;内容&gt; [&gt;或者&gt;&gt;] &lt;文件名&gt;[1] echo outputContent - 在控制台中输出[2] echo content &gt; targetFile - 把内容写入到目标文件中 touch命令[1] touch fileName - 创建不包括内容的文件 mv命令[格式] mv &lt;源文件/目录&gt; &lt;新文件名/目录&gt;[1] mv existFilename targetFolder - 把文件移动到目标目录下[2] mv existFile newFileName - 修改文件名字 cp命令 - 将源文件复制到目标文件，或者将多个源文件复制到目标文件[格式] cp [选项] &lt;源文件&gt; &lt;目录&gt;[1] cp existFilename targetFolder - 复制文件到指定目录[2] 配置参数 -n/–no-clobber: 不要覆盖已存在文件，与下面的-i互斥使用。（经测试，cp的默认行为是覆盖，至少 mac 是这样的 😳）。 -i/–interactive: 覆盖前询问 -r: 递归复制，用于复制目录 -f/–force: 强行复制文件或内容，不论目的文件或目录是否已存在 -u/–update：只有在源文件比目标文件新时才复制 一般我们会有两种操作： 一种是复制目录下的所有内容，cp -r www/* output/www/ 一种是复制单个文件。cp nginx.conf output/ tar命令 - 可以用来压缩和解压文件[格式] tar [选项] &lt;打包文件名&gt; &lt;文件&gt; 其中压缩和解压只有一个参数之差，下面我们来看一下这几个参数吧。12345-z: 支持 gzip 解压文件-c: 建立新的压缩文件 // -v: 显示操作过程-f: 指定压缩文件-x: 从压缩的文件中提取文件 [1] 压缩 - 压缩的时候是c12cd outputtar -zcvf ../output.tar.gz *; - 将output目录中的所有文件压缩成上一级目录中的output.tar.gz文件 [2] 解压 - 解压的时候是x1tar -zxvf ../output.tar.gz; rm命令[1] 删除文件 - rm filename[2] 删除文件夹 - rm -rf folder mkdir命令 - 可以用来创建目录，要求命令执行用户有当前目录的写权限，且创建的目录不能已存在。如果创建的目录已存在会给予提示，但不会报错[格式] mkdir [选项] &lt;目录名&gt;[1] 创建文件夹 mkdir src[2] 创建多层文件夹 mkdir -p src/views/component - 看出带有参数 p 的命令会自动创建不存在的目录 复制和移动命令的总结注意移动和复制的区别 - 移动后源文件不在了，复制只是对源文件复制一份 复制多个文件到&lt;指定目录&gt; cp -r www/* dist/www/ 复制单个文件到&lt;指定目录&gt; cp nginx.conf dist/www/ 复制单个文件到指定&lt;目录下的文件&gt; cat nginx.conf &gt; ../nginx.conf.bak 移动单个文件/多个文件到指定目录 mv nginx.conf ./bak/ mv ./src/* ./bak/src - 注意这种src里面的内容被移动到./bak.src目录下，但是src目录还在 mv ./src ./bak/src - src被整个移动到./bak/src目录下 参考连接让你牛B加身的前端必会Linux命令]]></content>
      <categories>
        <category>nodejs</category>
        <category>工具🔧</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年学习计划安排]]></title>
    <url>%2F2020%2F02%2F20%2Ftodolist%2F</url>
    <content type="text"><![CDATA[2020年也是非常难得的一个春节，让我们上班多年的小伙子终于也过上了一段寒假，最近一边在家远程办公，一边也在吸收各种各样的知识，2019年末，开始认真学习了一下docker和容器技术，也输出了docker的学习笔记水牛下水系列（1）- 容器技术【docker入门基础，今天准备罗列一下2020年的工作和生活计划，希望到年底的时候对比一下有哪些具体实现了，哪些没有实现。 计划个人学习[❌] 团队建设家庭[✔] 2020年2月9号 - 给宝宝买了大疆的OSMO-pocket口袋相机，情人节礼物加生日礼物。[✔] 2020年2月15号 - 四医院检查出来我们有了小宝宝，大概十月份我们的小宝宝就出生了,获得称号 - “喜当爹”[❌] 2020年2月24号 - 宝宝的生日，我们结婚后的第二个生日[❌] 2020年3月30号 - 老妈生日，老妈退休后的第一个生日 其他[❌] 继续坚持健身，控制体重，尽量今年年底减到80-85kg[❌] 继续坚持篮球🏀左手的训练，训练身体协调性[❌] 继续坚持篮球🏀左手的训练，训练身体协调性 todo lists [❌] 优化nodejs打包构建部署自动化工具(客户端/服务端 )]]></content>
      <categories>
        <category>2020_todoList</category>
      </categories>
      <tags>
        <tag>2020_todoList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows常用命令 vs linux常用命令]]></title>
    <url>%2F2019%2F12%2F30%2FwinBat%2F</url>
    <content type="text"><![CDATA[最近总是在linux环境和win环境之间切换工作，一些常用的脚本在这两个系统中不太兼容，于是搜了一下有没有兼容的整合方案，下面是通过bat脚本的方式在win下兼容linux一些简单的命令，后面也准备把win的bat脚本相关的东西，随着工作中的使用，逐步整理在这个分类下… window下基本操作 新建文件夹 1) window - mkdir xxxx 或者 md xxxx2) linux - mkdir xxxx 进入文件夹 1) window - cd xxxx 2) linux - cd xxxx 新建文件 1) window - type nul&gt; xxx 或者 echo &gt; xxx 2) linux - touch xxxx 编辑文件 1) window - echo xxcontentxxx &gt; xxx （追加）/ echo xxcontentxxx &gt;&gt; xxx (累加) 2) linux - vi xxxx 查看文件 1) window - type xxxx 2) linux - cat xxxx 删除文件 1) window - del xxxx2) linux - rm xxxx 删除文件夹 1) window - rd xxxx2) linux - rm -rf xxxx 查看文件夹下文件信息 1) window - dir2) linux - ls 使用bat使得window兼容linux的命令 例如想要在window下通过使用ls查看文件夹的信息(类似dir的功能) 1234567问题：&apos;ls&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件？？1.在C：\windows 目录下新建一个文件 命名为 ls.bat 2.使用sublime（其他编辑器也可）打开 ls.bat 编辑这个文件 输入： @echo off dir 现在在window的cmd中敲入ls实际上执行ls.bat脚本中dir命令… Windows下使用curl get传递多个参数 http://localhost:8080/Api/system/login?username=admin&amp;password=000000&amp;userType=1 只能解析到username参数，其他参数解析不到解决办法 - 原因出在这个&amp;符号上，&amp;后面的参数会获取不到，正确的传参格式应该是：将url用”“括起来 curl &quot;http://localhost:8080/Api/system/login?username=admin&amp;password=000000&amp;userType=1&quot;]]></content>
      <tags>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5梳理]]></title>
    <url>%2F2019%2F12%2F20%2Fapp%2F</url>
    <content type="text"><![CDATA[梳理一下当今app的发展 等待更新…]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>web app</tag>
        <tag>hybird</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[devOps]]></title>
    <url>%2F2019%2F12%2F20%2FdevOps%2F</url>
    <content type="text"><![CDATA[梳理一下当今devOps的发展 等待更新…]]></content>
      <categories>
        <category>devOps</category>
      </categories>
      <tags>
        <tag>jekins</tag>
        <tag>docker</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水牛下水系列（2）- window 10下docker安装ubuntu并且通过ssh访问]]></title>
    <url>%2F2019%2F12%2F19%2Fdocker-ubuntu%2F</url>
    <content type="text"><![CDATA[在docker中安装ubuntu，并通过ssh链接docker容器中的ubuntu… 另外说一下，docker search ubuntu可以搜索所有关于ubuntu的镜像，有的环境不需要这样从头开始搭建… 不熟悉liux基础的可以看一下linux 基础及其服务器nginx静态资源部署 的前半部分介绍…不熟悉docker的可以看一下容器技术【docker入门基础】 准备工作 查看版本信息cat /proc/version //Linux version 4.4.0-18362-Microsoft (Microsoft@Microsoft.com) (gcc version 5.4.0 (GCC) ) #476-Microsoft Fri Nov 01 16:53:00 PST 2019 查看操作系统的版本号cat /etc/issue // Ubuntu 16.04.6 LTS \n \l 查看ubuntu操作系统版本 123456uname --a //Linux DESKTOP-PIJLFO2 4.4.0-18362-Microsoft #476-Microsoft Fri Nov 01 16:53:00 PST 2019 x86_64 x86_64 x86_64 GNU/Linuxuname --s 显示内核名字uname --r 显示内核版本uname --n 显示网络主机名uname --p 显示cpu uname --m 显示操作系统位数 更新apt-get源 12apt-get update -yapt-get upgrade -y 拷贝文件cp sourcefile distfile 编辑文件cat &gt; sourcesfile &lt;&lt; EOF编辑的内容EOF 打开文件并编辑vim sourcefile按i 进入insert模式按esc退出编辑模式:wq退出 启动ssh服务(需要apt-get安装openssh-server)/etc/init.d/ssh start 重启ssh服务service ssh restart 查看ssh服务运行状态/etc/init.d/ssh status 查看ssh服务端口ps -e | grep ssh 修改root密码passwd root 查看服务器ip(需要apt-get安装net-tools)ifconfig 第一步 从docker的镜像仓库获取ubuntu并安装 docker pull ubuntu // 默认安装latest版本 如果提示错误 no matching manifest for windows/amd64 10.0.18362 in the manifest list entries1234docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntuno matching manifest for windows/amd64 10.0.18362 in the manifest list entries 修改docker配置 再次从镜像仓库获取ubuntu镜像docker pull ubuntu 第二步 运行docker容器 查看下载下来的ubuntu镜像iddocker images 12REPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 549b9b86cb8d 21 hours ago 73.9MB docker run -d -it --name ubuntu-ssh 549b9b86cb8d -p 3316:22 bash 在后台运行ubuntu的容器，并且把宿主机的3316端口和容器的22端口建立映射关系 查看容器是否运行成功docker ps 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc8601064dab8 549b9b86cb8d "bash" 8 seconds ago Up 6 seconds 0.0.0.0:3316-&gt;22/tcp fervent_wilbur 可以看到端口映射已经建立完成 第三步 进入容器内部安装ssh docker exec -it c8601064dab8 bash 进入容器内部 第四步 修改ubuntu默认的apt-get镜像源更换ubuntu apt-get 源 为了优化ubuntu软件安装/更新速度，我测试了国内几家apt源的速度，发现北京交大的apt源速度相对最快，然后可以通过以下步骤更新ubuntu源 备份默认的apt源cd /etc/aptcp sources.list sources.list.bak 编辑sources.listcat &gt; sources.list &lt;&lt; EOF 粘贴镜像源地址12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main multiverse restricted universedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main multiverse restricted universedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main multiverse restricted universedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main multiverse restricted universedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main multiverse restricted universedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main multiverse restricted universedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main multiverse restricted universedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main multiverse restricted universedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main multiverse restricted universedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main multiverse restricted universe 执行end of file 推出编辑EOF查看文件是否编辑成功cat sources.list 更新aptapt-get update -y apt-get安装ssh和net-tools软件 ①ssh-client命令安装ssh客户端 apt-get install openssh-client ②ssh-server命令安装ssh的服务器端 apt-get install openssh-server ③安装完成后启动服务 /etc/init.d/ssh status 可以查看ssh的运行状态/etc/init.d/ssh start然后运行 ps -e|grep ssh 查看ssh的运行进程是否正常运行 ④vim编辑器 apt-get install vimvim /etc/ssh/sshd_config 进入到ssh的配置文件修改PermitRootLogin yes 1234//vim的基本操作1) 点击i进入到insert的编辑模式，开始修改文件2) 编辑完成，点击esc推出到insert的标记模式3) :wq退出vim ⑤重启ssh服务 service ssh restart 1* Restarting OpenBSD Secure Shell server sshd [ OK ] ⑥设置ubuntu登陆的root密码 passwd root 1234passwd rootEnter new UNIX password: root!@#$Retype new UNIX password:root!@#$passwd: password updated successfully ⑦安装net-tools工具包 apt-get install net-tools ⑧查看docker运行的ubuntu系统的ip地址 ifconfig ⑨退出容器 ctrl + D 保存一下安装好ssh/vim/net-tools的这个镜像（注意这是将容器container转化成镜像image，下次就可以使用这个镜像构建容器了） docker commit -m&quot;ubuntu with ssh and tools&quot; -a &quot;pis&quot; ubuntu-ssh/ 通过xshell工具连接 查看镜像的22端口对应的宿主机映射 docker port ubuntu-ssh 22 // 22端口是默认的ssh链接的port 10.0.0.0:3316 在xshell配置 1234主机：localhost端口：3316用户名：root密码：root!@#$ 如果一切ok的话就会登陆成功 12连接成功Last login: Fri Dec 20 05:40:55 2019 但是有时候docker里面ssh的版本和本地的版本不一样 会提示一些错误信息，下面就是我遇见的一种错误信息：Session.connect: java.io.IOException: End of IO Stream Read 大概搜了一下就是因为ssh版本不一样导致无法建立连接 vim /etc/ssh/sshd.conf 文件最后面添加算法123KexAlgorithms diffie-hellman-group1-sha1,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha1Ciphers 3des-cbc,blowfish-cbc,aes128-cbc,aes128-ctr,aes256-ctr 重新启动ssh service ssh restart再次xshell连接即可如果还是不行。推荐使用docker hub上已经有人安装好的ubuntu-ssh镜像docker pull rastasheep/ubuntu-sshd // 默认下载latest版本someone push的docker中已经安装好ssh的镜像github地址 12docker port test_sshd 220.0.0.0:49154 默认暴漏的49154端口，root密码也是root，在xshell中配置配置一下就可以访问了。。。别问了为啥最后才告诉你有这个东西… 参考文献更新ubuntu的镜像源window 10下docker安装ubuntu并且通过ssh访问]]></content>
      <categories>
        <category>水牛下水系列</category>
        <category>水牛下水系列（2）-  window 10下docker安装ubuntu并且通过ssh访问</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>image</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水牛下水系列（1）- 容器技术【docker入门基础】]]></title>
    <url>%2F2019%2F12%2F12%2Fdocker%2F</url>
    <content type="text"><![CDATA[最近一直在想着优化团队的开发流程，提高开发效率。其实一直也在学习和在实际工作中实践前端工程化，从使用git和svn这种版本控制工具管理多人协作开发的代码，到使用npm管理项目中各个依赖包，再到webpack对前端工程的打包，最后到使用jekins实现每日构建和发版，大部分的工作其实现在还是通过手动的方式在做。现在已经9021年了，距离我开始从事这份工作也已经过去了4年多的时间，想着让自己在提高一下的想法，开始这个《水牛下水系列》对前端工程化的系统总结，希望后面可以一步一步实现自己的想法。。。 关于至于为什么这个系列要叫《水牛下水》这个名字，而上个系列的nodejs学习叫做《山羊上山》，因为很小的时候父亲教我的一句对联，直到现在都很喜欢-&lt;山羊上山山碰山羊角&gt; &lt;水牛下水水没(mo)水牛腰&gt;…不熟悉liux基础的可以看一下linux 基础及其服务器nginx静态资源部署 的前半部分介绍… docker 简介 容器化平台 开源并托管在github 跨平台，支持window，macOs和Linux docker是一个用来装应用的容器，就像杯子可以装水，笔筒可以装笔，书包可以装书一样。你可以把任何应用以一种标准化的方式放到docker里面，然后通过docker仓库，在目的地服务器上轻量化部署移植… 1) Docker的思想 集装箱 保证程序移植的时候，不管安装到哪，不会却少东西. 标准化 运输方式标准化存储方式标准化api接口的标准化 隔离类似虚拟机，隔离硬件资源，方便创建和销毁，比虚拟机轻量 2) docker解决的问题 多环境一致性 =》docker解决了运行环境不一致所导致的问题. 基于linux的namespace和cgroup=》ldocker的隔离性保证了应用之间资源不会相互影响 应用程序打包工具=》让快速扩展，弹性伸缩提供标准化的简便操作 3) docker基本概念从代码仓库registry运输(ship)镜像image，然后在本地把镜像image通过build生成容器container 镜像(image) 容器(container) 仓库(registry) hub.docker.com 官方仓库 docker运行应用的过程从registry把image拉到本地本地，用命令将image运行起来，生成container 4) 虚拟机和docker的区别 虚拟机在宿主机上有虚拟层来虚拟出硬件，在硬件上安装独立的操作系统，分配硬件资源等 docker 在docker引擎上隔离出不同的进程，分配不同的资源。 5) Mac/Linux/Window 安装docker mac安装docker docker.com官网手动下载dmg安装包安装 通过homebrew安装dockerbrew cask install dockerdocker info或者docker --version 可以验证docker是否安装成功 linux安装docker 使用wget下载工具安装sudo wget -qO- https://get.docker.com | sh 使用sudo超级管理员身份运行wget下载工具从get.docker.com下载docker，-q就是简化输出信息，大写的O减号 就是把wget的输出不是输出到文件，而是sh命令行标准输出的方式 window安装docker docker.com官网手动下载iso安装包安装 安装成功侯可以查看docker版本信息 version可以看到简单的信息 --version可以看到client和server的信息 docker info可以看到详细的信息 6) docker的使用 第一步：从镜像仓库获取镜像 在镜像仓库https://hub.docker.com获取镜像源 第二步：拉去/推送镜像 docker pull imageName:TAG例如 docker pull centos,默认就是latest的最新版本 docker push xxxx就是推送本地的image到registry 第三步：将镜像image转化为容器container 因为镜像是只读的(RO-read-only)，而容器是可读写的(RW-read-write)，所以要执行docker run xxx将image装换成container 前台运行镜像docker run imageName 后台运行镜像-d参数docker run -d imagename 可以看到可以使用docker images查看本地已经从仓库registry获取了哪些镜像image 使用docker ps -a可以查看哪些镜像image已经生成了容器container 使用docker ps可以查看哪些镜像image已经生成了容器container，并且在运行中 第四步：进入容器内部操作 进入docker容器内部通过exec执行命令docker exec -it imageName bash 第五步：退出容器 exit或者ctrl + D 第六步：将容器转化成镜像 docker commit -m &quot;新的image描述信息&quot; -a &quot;指定用户信息&quot; containerId 用户信息/新的image名字：tag 例如 docker commit -m&quot;centos with nginx install &quot; -a &quot;pis&quot; f2321sds032 pis/centos-nginx:v1 如果要发布这个镜像到docker仓库，最好在-a后面指定的用户名为docker hub的用户名.如果不把这个容器打成新的镜像，那么下次重新run的时候生成新的container还是没有安装好的程序，所以需要通过commit打成新的image，有点像git的commit就是一次记录 这样下次通过docker run centos的时候还是基于官方仓库下载在本地的cenos的image生成container，所以里面安装的nginx不存在; 但是如果通过docker run centos-nginx这个基于上次已经安装过nginx的containerid容器生成的镜像image，重新run就会生成一个新的安装好nginx的container 或者通过docker ps -a查到上次安装过nginx的containerId，然后通过docker start containerId重新拉起这个已经安装过nginx并且存在的容器，那么里面的nginx还是存在 第七步：存储镜像 docker images 查看本地全部的镜像image，找到自己根据container生成的镜像，例如：unclepis/centos-nginx:v1 去[hub docker仓库](https://hub.docker.com/)进行注册 docker login 登陆仓库 docker push 新的镜像名字 由于官方仓库再境外，可能推送的时候报错TLS handshake timeout超时 别人使用的时候直接docker pull xxxx 就把这个镜像拉到了本地 这么一个从registry=&gt;image=&gt;container的过程纯手动一个步骤一个步骤是不是有点麻烦？OK=&gt;new solution=&gt;Dockerfile 7) 使用dockerfile 文件的命名也必须为 Dockerfile，Docker 从上到下的顺序运行Dockerfile 的指令，每一个指令都以 step 为步骤来创建一个新的镜像层 Dockerfile 是用来构建自定义 Docker 镜像的文本文档 docker build -t imageName contextPath 就会读取contextPath上下文的dockerfile文件来构建镜像 imageName。注意默认的版本就是latest 123456FROM centosRUN yum update -yRUN yum install -y nginxCOPY . /usr/share/nginx/htmlEXPOSE 80CMD ["nginx", "-g", "daemon off;"] 然后通过docker run -p 80:80 unclepis/centos-nginx:V2 关联容器的80端口和宿主机的80端口 通过浏览器访问localhost:8080就可以看见结果了 dockerfile配置解析 参考链接Docker简明教程9102 年了，学点 Docker 知识]]></content>
      <categories>
        <category>水牛下水系列</category>
        <category>水牛下水系列（1）- 容器技术【docker入门基础】</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>image</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用express创建一个web服务]]></title>
    <url>%2F2019%2F12%2F09%2Fexpress%2F</url>
    <content type="text"><![CDATA[express是一个快速搭建web服务器的node框架，通过express或者express的cli工具express-generator就能快速的搭建一个http-server… express创建一个http-server1.安装express框架npm install express --save 2.创建server123456const express = require('express')const app = express()app.on(3000,()=&gt;&#123; console.log('server is running on 3000')&#125;) 3.什么是路由client==》url==》网络传输==》DNS域名解析==》server 根据路由响应客户端的请求 请求包括 请求方法req.method - get/post/put/delete/update 请求urlreq.url - https://xxxx.xxx.xxx/xxx/xx/xxxx?username=zhangsan&amp;&amp;password=123 请求的路径req.path - /xxx/xx/xxxx 请求参数 req.query - username=zhangsan&amp;&amp;password=123 4.处理路由 通过请求方式匹配处理 get/post等 1234567891011app.get('/list',(req,res)=&gt;&#123; res.json(&#123; msg:'method is,'+req.method &#125;)&#125;) app.post('/list',(req,res)=&gt;&#123; res.json(&#123; msg:'method is,'+req.method &#125;)&#125;) 通过path匹配处理 12345678910app.get('/api/blog/list',(req,res)=&gt;&#123; res.json(&#123; msg:'path is,'+req.path &#125;)&#125;)app.get('/api/user/list',(req,res)=&gt;&#123; res.json(&#123; msg:'path is,'+req.path &#125;)&#125;) 5.express 常用api all (匹配所有请求方式的xxxx) 12345app.all('/xxx',(req,res)=&gt;&#123; res.json(&#123; msg:'match all the methods' &#125;)&#125;) (匹配所有的uri) 12345app.all('*',(req,res)=&gt;&#123; res.json(&#123; msg:'match all the methods' &#125;)&#125;) use 建议中间件使用使用和all优点类似 1234567891011app.use('/xxx',(req,res)=&gt;&#123; res.json(&#123; msg:'match all the methods' &#125;)&#125;) app.use((req,res)=&gt;&#123; res.json(&#123; msg:'match all the methods' &#125;)&#125;) 6.express.Router()路由拆分 在app中使用use匹配根路由123// 注册路由app.use('/api/blog',blogRouter)app.use('/api/user',userRouter) 在业务路由中再匹配具体的路由 在blogRouter中定义路由123456789101112131415161718192021222324252627282930//blogRouterconst express = require('express')const router = express.Router() // router // .[method] // all // userouter.get('/list',(req,res,next)=&gt;&#123; res.json(&#123; msg:'获取列表成功' &#125;) return&#125;)router.post('/new',(req,res,next)=&gt;&#123; res.json(&#123; msg:'新增成功' &#125;) return&#125;)router.post('/del',(req,res,next)=&gt;&#123; res.json(&#123; msg:'删除成功' &#125;) return&#125;)module.exports = router 在app.js中注册拆分的路由12345678910// app.js const express = require('express') const app = express() const blogRouter = require('./router/blog.js') const userRouter = require('./router/user.js') const commonRouter = require('./router/common') // 404 // 注册路由 app.use('/api/blog',blogRouter) app.use('/api/user',userRouter) app.use(commonRouter) 中间件 中间件是一个函数 (error,req,res,next)=&gt;{} 分类 1.app级别的中间件 - 在app注册的时候声明使用 app.use(middleWare) 2.router级别的中间件 - 在路由拆分之后使用 router.use(middleWare) 12345678910111213141516171819202122232425const isValid = (req,res,next)=&gt;&#123; if(req.query&amp;&amp;req.query.id)&#123; next() // 交出控制权 &#125;else&#123; res.json(&#123; msg:'id不能为空' &#125;) &#125;&#125;// 1. 使用use的方式使用路由中间件======================================router.use(isValid)router.get('/list', (req, res) =&gt; &#123; res.json(&#123; msg: '获取列表成功' &#125;) return&#125;)// 2.在路由内部使用 =====================================router.get('/list',isValid, (req, res) =&gt; &#123; res.json(&#123; msg: '获取列表成功' &#125;) return&#125;)]]></content>
      <categories>
        <category>express</category>
        <category>使用express创建一个web服务</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Nxx(🐂x)系列(4) - Npx - node的包执行工具的使用和安装]]></title>
    <url>%2F2019%2F12%2F05%2Fnpx%2F</url>
    <content type="text"><![CDATA[npx主要解决了一下几个问题: 局部安装的包没有设置环境变量，不能很方便的在本项目目录下和全局其他任意路径下使用 全局安装包在全局任何位置都可用，但是占用本机存储，而且项目中一旦引用了全局的模块，版本容易不一致. 这个都是项目中很常见的问题，我们很多时候不得不在每个项目重复安装相同的模块包，为了在自己的项目中方便使用;实在为了方便全局安装了，一旦项目中引用，多人协作的时候依赖版本可能会不一致…针对这些问题，我们今天说一下npx这个安装工具的使用… npx 在 npm@5.2.0 版本之后，增加 npx 以提供来一些辅助的功能，全名 Node Package Executor - node的包执行工具 手动安装 - 万一不能用，就要手动安装一下。npm install -g npx ===================================================================================================== 用途1：调用局部安装包npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 http-server 局部安装http-servernpm install -D http-server 一般来说，调用 http-server ，只能在项目脚本和 package.json 的scripts字段里面， 如果想在命令行下调用，必须像下面这样。 项目的根目录下执行$ node-modules/.bin/http-server -p 9999 script脚本123456&#123; "script":&#123; "dev":"http-server -p 9999" &#125;&#125;// npm run dev npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了npx http-server -p 9999 npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。 由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。 优点： 任何command都通过npx在machine任何位置使用 ===================================================================================================== 用途2：避免全局安装模块，执行一次性命令 对于一些工具，比如create-react-app，它们有些特性： 可能很久才会被使用一次 安装包会很大 全局安装劣势： 占用本机空间 包安装在Node安装目录下的node_modules文件夹中 版本问题 假如一个项目中的某一个dependency是全局安装的，也就意味着不同的开发人员使用的这个dependency版本完全基于本地的版本，也就会导致不同的开发人员使用不同的版本 再也不需全局安装任何工具只需要npx npx create-react-app my-react npx 可以运行它create-react-app，而且不进行全局安装。 下载到一个临时目录，使用以后再删除。 以后再次执行上面的命令，会重新下载 优点： 不会污染本机的存储 永远使用最新版本的dependency ===================================================================================================== 用途3：帮助切换版本 npx的-p选项允许您指定要安装的包，并将其添加到正在运行的$PATH中 当你没有nvm的时候，帮你方便的切换node版本，假设你本机安装的node版本是node@8，但是你的项目可能需要使用使用node@6做测试，如果你有nvm，可以使用nvm use v8.11，其实npx也可以帮你做成。 1234567使用npx -p node@6 npm run test：npx会帮助你下载node@6将此时的环境变成node@6版本使用node@6帮你执行npm run test命令执行完毕之后不会修改你原来的node版本指令可以理解为使用node@6版本运行npm run test 参考链接npx 介绍]]></content>
      <categories>
        <category>你不知道的Nxx(🐂x)系列</category>
        <category>你不知道的Nxx(🐂x)系列(4) Npx - node的包执行工具</category>
      </categories>
      <tags>
        <tag>npx</tag>
        <tag>你不知道的Nxx(🐂x)系列(4)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Nxx(🐂x)系列(3) - Nvm - (Node Version Manager)node版本管理工具的使用和安装]]></title>
    <url>%2F2019%2F12%2F05%2Fnvm%2F</url>
    <content type="text"><![CDATA[今天简单整理一下nvm的安装和基础使用… nvm 安装和管理 Node.js版本 node.js version manager 是一个node的版本管理工具 安装多版本 node/npmnvm install 4.2.2 列出已安装实例nvm ls 你可以通过以下命令来列出远程服务器上所有的可用版本：nvm ls-remote 切換版本nvm use 4.2.2 切换到最新版：nvm use node 每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。 我们还可以用 nvm 给不同的版本号设置别名： nvm alias awesome-version 4.2.2nvm use awesome-versionnvm unalias awesome-version // 取消別名 确认某个版本Node的路径nvm which 4.2.2 直接运行特定版本的 Nodenvm run 4.2.2 –version 在当前终端的子进程中运行特定版本的 Nodenvm exec 4.2.2 node –version]]></content>
      <categories>
        <category>你不知道的Nxx(🐂x)系列</category>
        <category>你不知道的Nxx(🐂x)系列(3) Nvm - (Node Version Manager)</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>你不知道的Nxx(🐂x)系列(3)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线上环境进程守护/负载均衡/日志管理的Node应用的进程管理 - pm2]]></title>
    <url>%2F2019%2F12%2F05%2Fpm2%2F</url>
    <content type="text"><![CDATA[1)一般方式启动一个node服务node app.js 遇到进程奔溃，手动启动 2)本地开发环境使用node monitor - nodemon启动一个node服务nodemon app.js 遇到进程奔溃，自动监听自动启动 3)线上环境使用pm2启动一个node服务pm2 遇到进程奔溃，会自动重启 pm2是一个进程管理工具,可以用它来管理你的node进程，并查看node进程的状态，当然也支持性能监控，进程守护，负载均衡等功能…下面来安装配置一下pm2在部署在线上服务器做nodejs服务的进程守护…总的来说特点有：1&gt;内建负载均衡（使用Node cluster 集群模块）- 自动检测空闲的进程2&gt;可以在后台运行 - 后台启动后命令行就不在占用了3&gt;可以0秒停机重载，（可以理解为不需要停机重启，在用户愉快的浏览页面时我们已经程序更新了）4&gt;控制台检测5&gt;日志管理6&gt;热重载 0.安装npm i pm2 -g 1.启动123pm2 start app.jspm2 start bin/wwwpm2 start pm2.conf.json // 从配置文件启动 2.查看启动的进程pm2 list 3.重新启动pm2 restart appName|id 4.停止 (停止还可以在启动起来)pm2 stop appName|idpm2 stop all // 关闭全部 5.删除(删除就没法再启动起来了)pm2 delete appName|idpm2 delete all // 删除全部 6.查看日志pm2 log appName|id 7.查看监控器分析问题cpu 内存的一些信息pm2 monit appName|id 8.查看基本信息pm2 info appName|id 配置项：（进程数量/ 日志文件目录等）pm2 start pm2.json // 通过配置文件启动pm212345678910111213141516// pm2.json的配置文件&#123; "apps": &#123; "name": "pm2-test-server", // 进程名称 "script": "app.js", // server文件 "watch": false, // 检测更新 "ignore_watch": [ // 忽略文件变化 "node_modules", "log" ], "instance": 4, // 进程数 "error_file": "log/err.log", // 错误日志 "out_file": "log/out.log", // 日志输出路径 "log_date_format": "YYYY-MM-DD HH:MM:SS" // 日志时间戳 &#125;&#125; PM2的多进程 1.为何使用多进程 1）内存是受限的例如nodejs一个单线程在32为操作系统下最大使用1.6G内存 2）内存：无法重复分利用机器全部内存 3）cpu：无法充分利用多核cpu的优势 2.多进程和redis：多进程之间，内存无法共享（多进程访问一个redis，实现数据共享） 遇到的问题就是多进程无法共享数据，所以需要通过redis来共享 demopm2 demo]]></content>
      <categories>
        <category>nodejs</category>
        <category>pm2 进程守护</category>
      </categories>
      <tags>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Nxx(🐂x)系列(2) - Nrm - (Node Registry Manager)node镜像源管理工具的使用和安装]]></title>
    <url>%2F2019%2F12%2F04%2Fnrm%2F</url>
    <content type="text"><![CDATA[在一般前端工程化中，npm这种node的包管理工具我们使用的比较多，但是由于很多包是托管在国外的服务器上，所以在装包的时候资源加载很慢，一般的做法我们就是引入第三方的镜像仓库(例如淘宝的镜像仓库:https://registry.npm.taobao.org),而更优的做饭是使用nrm进行管理...今天简单整理一下nrm的安装和基础使用... nrm nrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换 安装nrm 在命令行执行命令，npm install -g nrm，全局安装nrm。 使用 执行命令nrm ls查看可选的源。 123456789nrm ls*npm ---- https://registry.npmjs.org/cnpm --- http://r.cnpmjs.org/taobao - http://registry.npm.taobao.org/eu ----- http://registry.npmjs.eu/au ----- http://registry.npmjs.org.au/sl ----- http://npm.strongloop.com/nj ----- https://registry.nodejitsu.com/其中，带*的是当前使用的源，上面的输出表明当前源是官方源。 切换如果要切换到taobao源，执行命令nrm use taobao。 增加你可以增加定制的源，特别适用于添加企业内部的私有源，执行命令 nrm add &lt;registryName&gt; &lt;registryUrl&gt;，其中registryName为源名，registryUrl为源的路径。 1nrm add registryName http: //registry.npm.frp.trmap.cn/ 删除执行命令nrm del &lt;registry&gt;删除对应的源。 测试速度你还可以通过 nrm test &lt;registry&gt;测试相应源的响应时间。 1nrm test npm]]></content>
      <categories>
        <category>你不知道的Nxx(🐂x)系列</category>
        <category>你不知道的Nxx(🐂x)系列(2) Nrm - (Node Registry Manager)</category>
      </categories>
      <tags>
        <tag>nrm</tag>
        <tag>你不知道的Nxx(🐂x)系列(2)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Nxx(🐂x)系列(1) - Npm - (Node Package Manager)node包管理工具的使用和安装]]></title>
    <url>%2F2019%2F12%2F04%2Fnpm%2F</url>
    <content type="text"><![CDATA[npm 常用的命令汇总最近使用verdaccio搭建私有npm仓库，用到很多的npm命令，特别整理一下，方便后面使用，毕竟现在前端都使用npm或者yarn这种包管理工具，学习一下npm常用命令和基本原理很有必要… npm(Node Package Managemer)npm 是node的模块管理器。我们只要一行命令就可以安装别人写好的模块，它包括两层含义: 基于Node.js开发的包的托管网站,模块登记和管理系统，regitry cli命令行模块管理器 安装nodejs自动安装npm (1)npm 基本操作12345npm docs 包名 查看包的文档npm help #查看npm命令列表npm -l #查看各个命令的简单用法npm -v #查看npm版本npm config list -l # 查看npm配置 npm init初始化生成一个package.json文件 1npm init -y # 使用默认配置生成一个package文件 npm set由于npm init里面有很多默认的设置，如果需要修改默认设置，这样以后初始化项目都使用配置的默认设置就可以使用npm set 1npm set init-author-name 'uncle pis' # 修改package的作者姓名 npm install／install -f 普通安装包／强制安装每个模块可以“全局安装”，也可以“本地安装”。 “全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和gulp。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 1npm install &lt;packageName&gt;#安装模块到node_modules目录 执行install之前，会检查node_modules目录之中是否已经存在指定模块，存在不再重新安装，即使远程仓库发布了一个新的版本，也不会安装 希望一个模块无论是否安装过，npm都强制重新安装可以使用-f或者--force 注意一下安装的时候，项目相关的要放在 -S下的dependency中，开发环境和工具相关的要放在-D的devDependency中 npm install 默认会安装dependecy和devDependency的包，如果–production则会安装dependency而不会安装 12345678npm install &lt;packageName&gt; --force #强制安装npm i &lt;packageName&gt;#缩写npm i &lt;packageName&gt;@&lt;version range&gt;#npm i npm@latest 指定版本// “devDependencies”: These packages are only needed for development and testing.（这些包仅用于开发和测试）npm i &lt;packageName&gt; -D # –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。//“dependency”:These packages are required by your application in production.（这些软件包是生产中的应用程序需要的）npm i &lt;packageName&gt; -S # –save：模块名将被添加到dependencies，可以简化为参数-S。 npm i &lt;packageName&gt; -g # 或者－－global 如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。 12rm -rf node_modulesnpm install 全局安装和局部安装的区别:npm uninstall12npm uninstall [package name] #卸载本地模块npm uninstall [package name] －g #卸载全局模块 npm update它会先到远程仓库查询最新的版本，然后查询本地版本，如果本地版本不存在或者远程较新，就会更新安装1npm update &lt;packageName&gt; #更新已经安装的模块 npm查询服务(registry)npm模块仓库提供一个查询服务叫做registry。例如npmjs.org提供的查询服务网址是 https://registry.npmjs.org/ 服务后面跟上模块名字就会得到一个json对象，里面是改模块所有的版本信息。比如，访问 https://registry.npmjs.org/react，就会看到 react 模块所有版本的信息。 返回的json对象里面又一个dist.tarball属性，是该版本的压缩包地址。使用npm install或者npm update就是通过这个方式安装模块的 模块安装过程12341.发出npm install命令2.npm向registry查询服务发送请求，查询模块压缩包的地址3.下载压缩包，存放在本地的缓存目录4.解压压缩包到当前目录的node_modules 运行npm install只会检查本地的node_modules存不存在需要的包，不会检查缓存 所以缓存里面有，但是node_modules里面没有，还是会从远程的npm仓库下载一次 查看npm源1npm config get registry 设置npm源1npm config set registry xxxxx npm run npm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。 npm内置了两个命令简写，npm test等同于执行npm run test，npm start等同于执行npm run start。 先运行npm run build-js，然后再运行npm run build-css，两个命令中间用&amp;&amp;连接。如果希望两个命令同时平行执行，它们中间可以用&amp;连接 npm run命令还可以添加参数,如果要通过npm test命令，将参数传到mocha，则参数之前要加上两个连词线。 参考连接阮一峰npm 模块安装机制简介阮一峰 npm模块管理器]]></content>
      <categories>
        <category>你不知道的Nxx(🐂x)系列</category>
        <category>你不知道的Nxx(🐂x)系列(1) Npm - (Node Package Manager)</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>你不知道的Nxx(🐂x)系列(1)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electron - 基于nodejs和chromium的跨平台桌面应用]]></title>
    <url>%2F2019%2F12%2F04%2Felectron%2F</url>
    <content type="text"><![CDATA[官方：Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 个人理解：electron就是一个nodejs应用程序，然后使用了chromium作为他的GUI视图，它可以使用纯javascript调用原生操作系统的api来创建桌面应用，使用javascript，html和css渲染视图。 精简版理解所以你能把它看作成一个被 JavaScript 控制的，精简版的 Chromium 浏览器。 electron应用1) 先初始化一个node应用1npm init -y 这样就生成一个package.json文件 12345&#123; "name": "your-app", "version": "0.1.0", "main": "index.js",&#125; 2) main指定node程序的主入口，如果没有指定就加载当前根目录下的index.js12345&#123; "name": "your-app", "version": "0.1.0", "main": "main.js" // 修改程序的主入口&#125; 3) 通过npm的node package manager安装electron包1npm install --save-dev electron 4) 添加scripts脚本引导node去执行当前的electron应用12345678&#123; "name": "your-app", "version": "0.1.0", "main": "main.js", "scripts":&#123; "start":"electron ." &#125;&#125; 5) 本地开发可以使用nodemon(node monitor)来监听本地文件变化触发热更新1234567891011// 安装nodemonnpm install nodemon -D // 编写npm脚本 &#123; "name": "your-app", "version": "0.1.0", "main": "main.js", "scripts":&#123; "start":"nodemon --watch main.js --exec electron ." // 监听main.js文件变化后执行electron . &#125;&#125; 项目搭建 可以使用 electron-forge的脚手架cli工具初始化一个项目，然后使用electron-builder将程序打包成不同的安装包 12345678910// 安装prebuild依赖npm install electron-prebuilt-compile -g --registry=https://registry.npm.taobao.org// 安装npm i electron-forge -g --registry = https: //registry.npm.taobao.org// init项目electron-forge init my-first-electron// cd cd my-first-electron// runnpm start 也可以clone官方的electron-quick-start项目，npm install&amp;&amp;npm start就可以跑起来一个简单的electron项目 应用架构mainProcess 主进程 在package.json中配置的main脚本就是一个主进程 electron应用有且只有一个主进程 主进程通过nodejs的api可以调用底层原生api（普通浏览器在沙盒模型中无法访问操作系统的原生资源） 可以通过ipcMain和渲染现成通信 可以操作nodejs和dom的apirenderProcess 渲染进程 可以有一个或多个渲染进程 可以操作nodejs和dom的api 可以通过ipcRenderer和主进程通信 代码演示1234567891011121314151617181920212223242526// 主进程const &#123;app,BrowserWindow&#125; = require('electron') // 只能在主进程中使用app.on('ready',()=&gt;&#123; const mainWindow = new BrowserWindow(&#123; // 主进程使用 BrowserWindow 实例创建页面 width:800, height:600 &#125;) mainWindow.loadFile('./index.html') // 每个 BrowserWindow 实例都在自己的渲染进程里运行页面&#125;)// index.html&lt;body&gt; &lt;div id="content"&gt;暂无数据&lt;/div&gt; &lt;button id="btn"&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;script&gt; require('./index.js') // 渲染进程,使用nodejs的api&lt;/script&gt;// index.jsconst &#123;BrowserWindow&#125; = require('electron').remote; // 通过remote可以在渲染进程中引入BrowserWindow创建页面等价于const &#123;remote&#125; = require('electron')const &#123;BrowserWindow&#125; = remote;const renderWindow = new BrowserWindow() 从上面代码可以看见：在主进程中通过electron.BrowserWindow创建了渲染进程的实例页面 主线程和渲染线程通信 通过ipcMain和ipcRenderer的事件 12345678910111213141516171819// 主进程const &#123;app,BrowserWindow,ipcMain&#125; = require('electron')app.on('ready',()=&gt;&#123;const mainWindow = new BrowserWindow(&#123; width:800, height:600 &#125;) mainWindow.send('sendToRenderProcess','i am from mainProcess') // 主进程发送事件&#125;)或者// 监听从渲染进程发送过来的事件ipcMain.on('sendFromRender',(event,arg)=&gt;&#123; // 向渲染进程发送事件 event.render.send('sendToRenderProcess','i am from mainProcess')&#125;)ipcMain.on('sendFromRenderProcess',(event,msg)=&gt;&#123; console.log(msg) // i am from renderProcess&#125;) 这样主进程mainProcess的消息就发送给渲染进程renderProcess了 12345678const &#123;ipcRenderer&#125; = require('electron')// 渲染选中的列表ipcRenderer.on('sendToRenderProcess', (event, msg) =&gt; &#123;// 接收从主进程发送过来的事件 console.log(msg) // i am from mainProcess // 向主进程发送事件 ipcRenderer.send('sendFromRenderProcess','i am from renderProcess')&#125;)]]></content>
      <categories>
        <category>electron</category>
        <category>基于nodejs和chromium的跨平台桌面应用</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（7）- 日志管理]]></title>
    <url>%2F2019%2F11%2F27%2Fnodejs-7%2F</url>
    <content type="text"><![CDATA[日志是一个后台服务的眼睛，一旦系统出现了问题，系统的日志就能帮助我们快速定位问题，所以日志是非常重要的，本章就在nodejs的fs模块的基础上，讲解日志管理… 本篇幅主要的技术点[❌] 使用node原生http模块搭建http-server[❌] 使用nodemon处理热加载[❌] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[❌] 使用querystring处理get请求的参数[❌] 使用promise的方式获取post请求body参数的获取[❌] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[❌] mySql常用操作汇总[❌] nodejs链接本地mysql数据库响应客户端请求[❌] 登陆校验/登陆信息存储[❌] nodejs链接redis数据库[❌] nginx的配置反向代理[✔] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） 日志分类 访问日志 - access log （sever端最重要的日志） 自定义日志 - 包括自定义事件event log/错误日志error log等 日志文件的存储 - 文件存储 日志文件很大，为了cpu和存储的方便，不可能存储在redis中，因为redis是内存数据库，太消耗内存，影响性能，成本太高 mysql适合于表结构类型数据的存储，日志文件记录的内容不太适合。 nodejs的文件操作 基本的文件操作readFile/writeFile 异步的操作123456789101112131415161718192021222324252627const fs = require('fs') // 读取文件的fs模块const path = require('path') //跨操作系统拼接文件路径// 文件读取const filename = path.resolve(__dirname, 'file1.txt');fs.readFile(filename,(error,data)=&gt;&#123; if(error)&#123; console.log(error) return &#125; console.log(data.toString()) // 将流文件转换成字符串打印&#125;)// 文件写入const content = '这是写入的内容'const opt = &#123; flag:'a' // a是append累加写入，w是write覆盖&#125;fs.writeFile(filename,content,opt,error=&gt;&#123; if(error)&#123; console.log(error) &#125;&#125;)// 判断文件是否存在fs.isExist(filename,(isExist)=&gt;&#123; console.log(isExist) // true 、false&#125;) nodejs stream流 因为文件的读取和写入都是异步的，而且不管是文件io还是网络io都容易阻塞，而且很慢，所以我们在日志中使用stream流的方式进行: 标准输入输出 1process.stdin.pipe(process.stdout) req和res都是支持stream的方式 12345678// stream 实现网络io传输const http = require('http')const server = http.createServer((req,res)=&gt;&#123; if(req.method === 'POST')&#123; req.pipe(res) // post请求中postData传入的数据就会在res中直接返回 &#125;&#125;)server.listen(3000) 流的io操作：fs.createReadStream(filename)/fs.createWriteStream(filename) 1234567891011121314151617// stream实现文件io操作const fs = require('fs')const path = require('path')const file1 = path.resolve(__dirname,'file1.txt')const file2 = path.resolve(__dirname,'file2.txt')const readStream = fs.createReadStream(file1)const writeStream = fs.createWriteStream(file2)readStream.pipe(writeStream) // 读取file1中的文件并通过stream流的方式一点一点写入file2// 跟获取postData一样，也有个data/end事件为文件读取的数据和读取完成readStream.on('data',chunk=&gt;&#123; console.log(chunk.toString())&#125;)readStream.on('end',()=&gt;&#123; console.log('finished')&#125;) 1234567891011const http = require('http')const fs = require('fs')const path = require('path')const file1 = path.resolve(__dirname,'file1.txt')const readStream = fs.createReadStream(file1)const server = http.createServer((req,res)=&gt;&#123; if(req.method === 'get')&#123; readStream.pipe(res) // 文件io读取文件通过网络io传输到浏览器返回数据 &#125;&#125;)server.listen(3000) 日志功能的开发和使用123456789101112131415161718192021222324// logsconst fs = require('fs')const path = require('path')const createWriteStream = (filename)=&gt;&#123; const fullFileName = path.join(__dirname,'../','../','logs',filename) const writeStream = fs.createWriteStream(fullFileName,&#123; flag:'a' &#125;) return writeStream&#125;const writeStream = createWriteStream('access.log');const access = (log)=&gt;&#123; if(process.env.NODE_ENV ==='dev')&#123; console.log(log) // 本地开发打印出来 &#125;else&#123; writeStream.write(log + '\n') // 线上环境写入日志 &#125;&#125;module.exports = &#123; access&#125; // serverHandler1access(`$&#123;req.method&#125; -- $&#123;req.url&#125; -- $&#123;req.headers['user-agent']&#125; -- $&#123;Date.now&#125; `) 日志文件的拆分（服务器环境一般通过定时任务按照日期进行拆分） 日志文件累计的话，在一个文件中不好维护，而且进行日志分析，一般是按照日期一天一天的分析，所以按照一天或者一小时为维度拆分日志很有必要 在linux通过crontab命令定时任务来拆分日志 12// 设置定时任务的格式：***** command （*分别代表分钟，小时，日期，月份，星期几）如果为*则忽略，否则则一个单元执行一次，例如 1 **** command意思为每1分钟执行这个shell脚本command命令，21***为每天第一个小时第二分钟执行 将access.log每天拷贝并重命名为yyyy-mm-dd.access.log并清空access.log给明天继续使用 123456789// copy.sh#!/bin/sh cd logcp access.log $(date +%Y-%m-%d-%H).access.logecho "" &gt; access.logcrontab -e // 进入编辑模式* 0 * * * sh ../xx/xxx/xxx/copy.sh // 每天第0小时执行sh脚本 日志分析 日志是按行存储的，一行就是一条日志 使用nodejs的readline(基于stream，效率高)来逐行分析日志 1234567891011121314151617181920212223242526272829303132const fs = require('fs')const path = require('path')const readline = require('readline')// 日志文件名const fileName = path.join(__dirname,'../','../','logs',access.log)// 创建readStreamconst readStream = fs.createReadStream(filename)// 创建readline对象const rl = readline.createInterface(&#123; input:readStream&#125;)let rowSum = 0let getSum = 0 // get请求数// 开始读取文件rl.on('line',lineData=&gt;&#123; if(!lineData)&#123; return &#125; rowSum++; const arr = lineData.split('--'); if(arr[0]&amp;&amp;arr[0]==='GET')&#123; getSum ++ &#125;&#125;)// 监听读取文件完成rl.on('close',()=&gt;&#123; if(rowSum)&#123; console.log('get请求占比'，(getSum/rowSum).toFix(2)) &#125;&#125;) 总结通过fs的stream就完成了网络io和文件io的日志，已经通过linux的定时任务完成日志拆分，通过fs的readline完成了日志分析…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (7) - 日志管理</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（7）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（6）- nginx反向代理]]></title>
    <url>%2F2019%2F11%2F27%2Fnodejs-6%2F</url>
    <content type="text"><![CDATA[到目前为止，就完成了登陆，需要用http-server在一个端口（例如8000端口）拉起html的静态页面，然后再html中访问我们使用nodejs写的后台程序(例如8081端口)进行前后端联调，因为端口不一致，http请求时跨域的，所以我们就需要使用nginx做反向代理，来解决跨域的问题… 本篇幅主要的技术点[❌] 使用node原生http模块搭建http-server[❌] 使用nodemon处理热加载[❌] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[❌] 使用querystring处理get请求的参数[❌] 使用promise的方式获取post请求body参数的获取[❌] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[❌] mySql常用操作汇总[❌] nodejs链接本地mysql数据库响应客户端请求[❌] 登陆校验/登陆信息存储[❌] nodejs链接redis数据库[✔] nginx的配置反向代理[❌] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） nginx简介 1.nginx是一个高性能的Web服务器和反向代理服务器，也可作为电子邮件代理服务器。 2.在连接高并发的情况下，nginx是Apache服务不错的替代品，能够支持高达 50,000 个并发连接数的响应。 3.一般做静态服务和负载均衡. 正向代理与反向代理 1.反向代理:对客户端不可见的代理是指以代理服务器(例如nginx服务器)来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回到Internet上请求连接的客户端，此时代理服务器对外表现为一个反向代理服务器。 2.正向代理：客户端可以控制的代理正向代理，是在用户端的。是指用户无法访问某网站，但是可以访问某代理服务器，而代理服务器可以访问该网站。于是用户通过访问代理服务器去访问该网站，代理服务器把响应信息返回给用户。 3.反向代理中用户访问的IP和端口是nginx服务器的，不知道提供服务的底层服务器，底层服务器在内网中，对外公开的是nginx服务器，nginx充当中间层。 4.而正向代理中用户是知道目标服务器的域名信息的，只是迫于网络的限制无法访问，如最常见的访问外网。 配置nginx1234nginx -t //测试配置文件是否正确nginx -s reload nginx startnginx stop 可以再window下配置bat结尾的脚本文件 start.bat 12345@ECHOstart nginx.exepause stop.bat 12345@ECHO nginx -s stop pause 配置nginx.conf文件1234567891011121314151617181920212223242526272829303132# cpu多核的话可以启动多个实例worker_processes 4;# blog系统测试nginx配置 server &#123; # 监听nginx的8000端口 listen 8000; server_name localhost; # http连接超时时间，默认是65s。上传文件比较大，在规定时间未上传完成，会自动断开连接 keepalive_timeout 100; client_header_timeout 120s; #调大点 client_body_timeout 120s; #调大点 client_max_body_size 500m; #主要是这个参数，限制了上传文件大大小 # ui location / &#123; root H:\\nodejs\\blog-client; index index.html index.htm; # 静态html文件代理到8001端口 proxy_pass http://localhost:8001; &#125; # api location /api/ &#123; # nodejs的后台服务起在8000端口 proxy_pass http://localhost:8000; # 代理之后把host传过来 proxy_set_header Host $host; &#125; &#125; 总结到此为止，我们就可以在客户端浏览器通过访问nginx服务器的http://localhost:8888访问到这个博客项目了，然后nginx监听8888端口,将前端html页面代理到http:localhost:8081上起的http-server拉起的静态页面,然后静态页面访问localhost:8888/api/xxx/xxx的接口的时候，又被nginx代理到localhost:8000/api/xxx/xxx上的nodejs进程拉起的server上。因为跨域只是针对客户端访问服务器的，现在通过nginx服务器反向代理，nginx服务器访问别的服务器就不存在跨域限制了…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (6) -  nginx反向代理</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（6）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（5）- cookie-session登陆校验 - 下]]></title>
    <url>%2F2019%2F11%2F26%2Fnodejs-5%2F</url>
    <content type="text"><![CDATA[在上一章cookie-session登陆校验 - 上中已经实现了通过cookie携带用户的username信息，然后在业务中判断用户是否登陆，是否有权限操作等功能；但是存在一个问题： cookie中存储了用户的敏感信息 cookie中明文存储了用户的username，username不光是用户名，可能是用户的手机号，邮箱等信息，在nodejs操作mySql数据库中我们讲过sql注入就是因为知道了用户的username绕过密码就完成了用户登陆。 所以本章节来介绍cookie-session机制来完成用户的登陆和登陆信息存储… 本篇幅主要的技术点[❌] 使用node原生http模块搭建http-server[❌] 使用nodemon处理热加载[❌] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[❌] 使用querystring处理get请求的参数[❌] 使用promise的方式获取post请求body参数的获取[❌] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[❌] mySql常用操作汇总[❌] nodejs链接本地mysql数据库响应客户端请求[✔] 登陆校验/登陆信息存储[✔] nodejs链接redis数据库[❌] nginx的配置反向代理[❌] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） 实现总览 判断cookie中是否存在sessionId，不存在生成随机的sessionId,初始化本地req.session和redis中根据sessionId为key的session数据 在router中拦截客户端的请求，如果路由匹配成功，设置cookie- res.setHeader(‘Set-Cookie’,userid=${req.sessionId}; path=/; httpOnly; expires=${getCookieExpires()}) 在登陆login接口调用成功后，从mysql数据库中读取但钱登陆用户数据，存储用户信息到本地req.session并同步更新redis 使用nodejs连接redis数据库 跟mysql一起根据node的环境变量配置线上和线下redis的环境，然后对redis的写入和读取方法进行封装，注意存入redis的数据需要序列化，读取的时候也要判断是否需要反序列化. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 // 引入redisconst redis = require('redis')let REDIS_CONFIG = &#123;&#125;// 获取node的环境变量const env = process.env.NODE_ENV// 根据线上线下地址获取redis的配置if (env === 'dev') &#123; REDIS_CONFIG = &#123; host: 'localhost', port: '6379' &#125;&#125; else &#123; REDIS_CONFIG = &#123; host: 'localhost', port: '6379' &#125;&#125;const PORT = REDIS_CONFIG.portconst HOST = REDIS_CONFIG.HOST// const redisClient = redis.createClient(PORT, HOST)redisClient.on('error', err =&gt; &#123; console.log(err)&#125;)// 保存数据到redis并序列化const saveInRedis = (key, value) =&gt; &#123; if (typeof value === 'Object') &#123; redisClient.set(key, JSON.stringify(value)) return &#125; redisClient.set(key, value, redis.print)&#125;//获取redis的数据并且反序列化const getFromRedis = (key) =&gt; &#123; redisClient.get(key, (err, val) =&gt; &#123; if (err) &#123; console.log(err) return &#125; return JSON.parse(val) // redisClient.quit() &#125;)&#125;module.exports = &#123; saveInRedis, getFromRedis&#125; 处理sessioncookie中存储一个sessionId来代替敏感信息username123456789101112131415161718192021222324// 标识生成的sessionId是否要存入cookielet needSetCookie = false;// 判断cookie是否已经存在sessionIdlet userId = req.cookie.userId;if(!userId)&#123; needSetCookie = true; // 新生成的才要存入 // 不存在生成一个 userId = `$&#123;Date.now()&#125;_$&#123;Math.random()&#125;` // 初始化session saveInRedis(userId, &#123;&#125;)&#125;req.sessionId = userId;getFromRedis(req.sessionId).then(sessionData =&gt; &#123; if (sessionData == null) &#123; // 初始化session saveInRedis(userId, &#123;&#125;) req.session = &#123;&#125; &#125; else &#123; req.session = sessionData; &#125; console.log('req.session', req.session) // 处理post请求异步的body中携带的数据 return getPostBodyData(req) &#125;) 在路由拦截器中根据needSetCookie标识设置cookie 因为这个serverHandler是所有请求的入口，这样就是只有当路由被拦截的时候才会写入cookie进行存储，404等异常的时候不存储cookie 在登陆的时候设置cookie 登陆成功后设置session到本地req.session并存入redis中 测试一下 不登陆访问一个login-test 登陆之后 查看redis中存储的数据 再测试一下login-test，打印session 总结到这里，我们就通过cookie中存储了随机数sessionId，然后将用户的敏感信息存储再redis中，实现了登陆以及登陆信息的存储。这个就是cookie-session机制系统登陆中的实现….现在比较常用的还有一种是JWT的方式(JSON WEB TOKEN),它的主要好处就是服务器不存储token信息，全部存储再浏览器端，然后每次请求都会将登录时生成的JWT信息带回服务器，这样服务器端就可以多服务器部署的时候不需要redis做持久化…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (5) - cookie-session登陆校验 - 下</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（5）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（4）- cookie-session登陆校验 - 上]]></title>
    <url>%2F2019%2F11%2F25%2Fnodejs-4%2F</url>
    <content type="text"><![CDATA[在上一章nodejs操作mySql数据库已经实现了博客系统的基本操作，但是有一些细节问题我们还没有处理，例如用户登陆之后要存储登陆用户的信息，然后登陆人只能删除和编辑自己创建的博客，这就牵扯到登陆的时候对当前登陆用户基本信息的存储… 本篇幅主要的技术点[❌] 使用node原生http模块搭建http-server[❌] 使用nodemon处理热加载[❌] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[❌] 使用querystring处理get请求的参数[❌] 使用promise的方式获取post请求body参数的获取[❌] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[❌] mySql常用操作汇总[❌] nodejs链接本地mysql数据库响应客户端请求[✔] 登陆校验/登陆信息存储[❌] nodejs链接redis数据库[❌] nginx的配置反向代理[❌] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） cookie-session 机制什么是cookie?1)存储在浏览器的一段字符串(最大5kb) 2)跨域不共享 3)格式为k1=v1;k2=v2; 4)每次发送http请求会将请求与的cookie一起发送给server 5)server端可以修改cookie并返回给浏览器 6)浏览器也可以通过js修改cookie(server端可以限制httpOnly不让客户端读取和修改cookie) 7)在浏览器中使用document.cookie的方式进行赋值其实是累加的过程。 javascript怎么操作和查看cookie- 浏览器查看cookie有三种方式 1)在network中的request里面查看cookie 2)在控制台document.cookie查看cookie 3)在application中的storage=&gt;cookies中查看cookie（name/value/domain/path/expire/max-age） server端nodejs怎么操作cookie实现登陆验证 查看cookie:req.headers.cookie 修改cookie res.setHeader(‘Set-Cookie’,username=${userInfo[0].username};path=/;) 登陆后设置cookie - res.setHeader(‘Set-cookie’,username=${userInfo[0].username};path=/;) 因为http协议是无状态的，需要通过上面所说的cookie来携带一些用户信息，在前后端通信的时候，来处理一些逻辑。1234567891011121314151617const userRouterHandler = (req, res) =&gt; &#123; // 用户登陆的接口 if (req.method === 'POST' &amp;&amp; req.path === `$&#123;interface&#125;$&#123;user&#125;$&#123;USER_LOGIN&#125;`) &#123; const &#123; username, password &#125; = req.body; let loginResult = login(username, password); return loginResult.then(userInfo =&gt; &#123; if (userInfo &amp;&amp; userInfo[0]) &#123; if (userInfo[0].username) &#123; // ------------------------------登陆成功后将用户信息存入cookie------------------------------------------ res.setHeader('Set-Cookie',`username=$&#123;userInfo[0].username&#125;;path=/;`) &#125; return new SuccessModal(userInfo, '登陆成功') &#125; return new ErrorModal('登陆失败') &#125;) &#125;&#125; 从req.headers.cookie获取cookie1234567891011121314151617181920212223242526const serverHandler = (req, res) =&gt; &#123; // 设置所有请求的响应头为json格式 res.setHeader('Content-type', 'application/json') // 解析客户端请求的基本数据 const method = req.method; const url = req.url; const queryString = querystring.parse(url.split('?')[1]); const path = url.split('?')[0] // 扩展req的参数 req.path = path; req.query = queryString; // --------------------------------解析cookie---------------------------------------------- req.cookie = &#123;&#125;; const cookieStr = req.headers.cookie || '' cookieStr.split(';').forEach(element =&gt; &#123; if (!element) &#123; return &#125; const arr = element.split('=') const key = arr[0] const value = arr[1] req.cookie[key] = value &#125;);&#125; 这样通过req.cookie就可以在cookie中获取登陆的时候用户的username，来做业务判断 存在的问题：现在虽然可以从req中获取cookie了，但是有一个问题: cookie可以被客户端浏览器修改 在本章开始的时候我们说过三种客户端浏览器可以查看cookie的办法，也分别说了客户端和server端怎么修改cookie，所以为了防止cookie在客户端被修改，我们需要使用httpOnly属性限制cookie被客户端修改 1res.setHeader('Set-Cookie',`username=$&#123;userInfo[0].username&#125;;path=/;httpOnly`) 归纳server读取cookie: req.headers.cookieserver设置cookie：res.setHeader(&#39;Set-Cookie&#39;,username=zhangsan;path=/;httpOnly)server读取content-type:res.headers[&#39;content-type&#39;] // 注意大小写server设置content-type:req.setHeader(&#39;Content-type&#39;,&#39;application/json&#39;) 总结到这里，我们通过登陆login的接口，将用户的username信息存入到cookie中，因为http是无状态的，所以通过cookie中存储的username就可以增加业务判断；并且后台设置的cookie通过httpOnly的限制，只能通过后台设置使用，客户端没法document.cookie的js方法查看和修改cookie中存储的信息。现在存在的问题就是cookie中存在用户的敏感信息，username可能是用户的手机或者邮箱又或者是具体的用户名，下一章节我们将通过在cookie中仅仅存储一个sessionId,它没有任何意义，然后将敏感信息通过sessionId存入redis中来规避这些问题…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (4) - cookie-session登陆校验 - 上</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（4）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（3）- nodejs操作mySql数据库]]></title>
    <url>%2F2019%2F11%2F25%2Fnodejs-3%2F</url>
    <content type="text"><![CDATA[在上一章节处理http请求我们已经完成了基本的http参数处理，并且抽离了模块，现在我们要使用nodejs链接mysql数据库，完成api接口中的业务处理… 本篇幅主要的技术点[❌] 使用node原生http模块搭建http-server[❌] 使用nodemon处理热加载[❌] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[❌] 使用querystring处理get请求的参数[❌] 使用promise的方式获取post请求body参数的获取[❌] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[✔] mySql常用操作汇总[✔] nodejs链接本地mysql数据库响应客户端请求[❌] 登陆校验/登陆信息存储[❌] nodejs链接redis数据库[❌] nginx的配置反向代理[❌] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） 数据库基本操作12345678910111213141516171819202122232425262728293031show databases; // 查看所有的数据库use databaseName; // 使用某一个具体的数据库show tables; // 查看数据库中所有的表select version(); // 查看数据库的版本不等于使用两个尖括号&lt;&gt; // update users set state="1" where id&lt;&gt;4-- show databases; // mysql中使用 --单行备注/*这是多行备注*/`关键字需要括起来`// 插入insert into TableName (ColumnsA,columnB) values (ColumnAValue,ColumnBValue)// 全部列查询（有性能问题，不建议使用*）select * from TableName ;// 固定列查询select ColumnA,columnB from TableName;// 条件查询select ColumnA from TableName where Column='VALUE'; // select id from users where username='123'// 多条件交集查询select ColumnA from TableName where ColumnB='valueB' and ColumnC="valueC"; // select id from users where username='123' and password='321'// 多条件并集查询select ColumnA from TableName where ColumnB='valueB' or ColumnC="valueC"; // select id from users where username='123' or password='321'// 模糊查询select ColumnA from TableName where ColumnB like '%value%' // select * from users where username like '%zhang%'// 排序select * from TableName order by Column desc // 降序 select * from users where password like '%23%' order by id desc;select * from TableName order by Column asc // 升序 select * from users where password like '%23%' order by id asc;// 更新update TableName set ColumnName='columnValue'// 多列更新(逗号分割)update TableName set ColumnNameA='ColumnNameAValue',ColumnNameB="ColumnNameBValue"// 删除delete from TableName where ColumnNameA='ColumnNameAValue' // delete from users where username='zhangsi' mysql忘记root密码的解决办法 1）首先在window系统下的话C:\ProgramData\MySQL\MySQL Server 5.7找打my.ini文件，增加 skip-grant-tables 选项前面曾经介绍过，意思是启动 MySQL 服务的时候跳过权限表认证。 启动后，连接到 MySQL 的 root 将不需要口令。 12// 文件最后增加一句 skip-grant-tables 2)在mysql安装目录的bin目录下执行 mysql -u root -p，然后不输入密码直接回车进入mysql. 3)用show databases; 查看数据库,在开头说过mysql的密码其实是保存在名为“mysql”的数据库中，所以切换到mysql数据库。 1use mysql // 切换到mysql数据库 4)修改密码:这里要根据版本来执行不同的SQL语句了，因为版本不同，存储密码的字段可能不相同。5.7以前的版本可以用以下语句更新root密码： 1update user set password = password('123456') where user='root'; 5)如果顺利的话，root的密码应该已经被修改为“123456”，那可以不必往下看了。然而我的mysql版本是5.7.21，所以第一次尝试的时候这里又报错了： 1ERROR 1054 (42S22): Unknown column 'password' in 'field list' 6）表中没有password字段，可以用desc user;指令看一下果然没有。查资料发得知5.7版本密码保存字段已经改成上图中的“authentication_string”了，于是重新输入update指令重置密码： 1update user set authentication_string = password('123456') where user='root'; 修改成功！！！！！！！ 7) 重启mysql在mysql安装目录的bin目录下执行cmd命令12net stop MySQL57; // 关闭mysql服务net start MySQL57; // 启动mysql服务 使用nodejs连接mysql数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const mysql = require('mysql') // 引入mysql// 定义mysql的配置let MYSQL_CONFIG = &#123;&#125;;// 读取nodejs本地运行环境const env = process.env.NODE_ENV;// 上篇文章中使用cross-env定义了node的运行环境变量"mock":"cross-env NODE_ENV=dev nodemon ./bin/app.js"// 如果是本地环境加载本地mysql的配置if(env=='dev')&#123; MYSQL_CONFIG =&#123; host:'localhost', port:'3306', user:'root', password:'mysql_2019' &#125;&#125;else&#123; MYSQL_CONFIG =&#123; host:'线上地址', port:'3306', user:'root', password:'mysql_2019' &#125;&#125;const db = mysql.createConnection(MYSQL_CONFIG);// 开始建立连接db.connect(error=&gt;&#123; if(error)&#123; console.log(error) return &#125;&#125;);// 数据库查询时异步的，暂时用promise封装一下，koa原生就支持asyn/await函数处理异步，封装处理sql的函数const queryDataBase = (sql)=&gt;&#123; return new Promise((resolve,reject))=&gt;&#123; db.query(sql,(error,result)=&gt;&#123; if(error)&#123; reject(error) return &#125; resolve(result) &#125;) &#125;)&#125;module.exports = &#123; queryDataBase, escape:mysql.escape // escape方法对特殊字符进行转码&#125; 根据业务来封装自己的api,通过sql查询数据库实现业务的增删改查操作 防止sql注入 因为在mysql中使用--就是备注，所以当我们在拼接sql的时候，如果对用户输入的参数不做处理，很容易引入sql注入的安全问题。例如: 12345678910const sql = `select * from users where username='$&#123;username&#125;' and password = '$&#123;password&#125;'`// 如果用户正常输入的username='zhangsan' and password = '123'就可以成功登陆// 加入只知道用户名不知道密码，但是用户名username输入为username = "zhangsan '--"sql = "select * from users where username='zhangsan' -- and password = '$&#123;password&#125;'"其实等价于sql = "select * from users where username='zhangsan'后面内容就被备注掉了，所以输入任何密码都能登陆 解决sql注入办法：引入escape方法对特殊字符进行转码1234567 //apiconst &#123;escape,queryData&#125; = require('../db/mysql.js') const login =(req)=&gt;&#123; const &#123;username,password&#125; = req.body const sql = `select * from users where username = $&#123;escape(username)&#125; and password = $&#123;escape(password)&#125;` return queryData(sql) &#125; 总结通过nodejs链接了数据库，首先可以根据配置的环境变量，对本地开发环境和线上环境做不同配置;再就是封装了mysql的查询和escape方法，分别根据sql操作数据库数据和防止sql注入…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (3) - nodejs操作mySql数据库</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（3）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水牛下水系列（0）- linux 基础及其服务器nginx静态资源部署]]></title>
    <url>%2F2019%2F11%2F18%2FlinuxDeploy%2F</url>
    <content type="text"><![CDATA[最近在公司本地的服务器用nginx部署了一个单页面的应用程序，做之前想想感觉过程挺简单的，无非就是打包静态资源，修改server的nginx配置然后就可以访问了，后来发现需要安装node环境，一方面需要安装前端工程的依赖包，另一方面需要使用nodejs起一个express的server…一般三折之后还是打算记录一下…. 链接远程服务器这个没啥可说的，一般都是使用xshell连接服务器，然后使用xftp将打包好的前端静态资源传输上去部署，在这分享一个工具—finalShell，这个工具是一个集成xshell和xftp的工具，还可以通过mstsc链接远程桌面。 linux基础一般来说著名的linux操作系统基本上分为两大类:1)RedHat系列：RedHat\Centos\Fedora等 - 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数” - 包管理工具 yum，yum可以用于运作rpm包 - 支持tar包 yum: 是redhat, centos 系统下的软件安装方式，基于Linux，全称为 Yellow dog Updater, Modified， 是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器 基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。 123安装：yum install卸载：yum remove更新：yum update 可以配置-y参数 yum install nginx -y 标识默认命令行交互的时候都是以yes 2)Debian系列：Debian\Ubantu等 - 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数” - 包管理工具 apt-get，可以用于运作deb包 - 支持tar包 ap-get是ubuntu下的一个软件安装方式，它是基于debain。123安装：apt-get install卸载：apt-get remove更新：apt-get update 可以配置-y参数 apt-get install nginx -y 标识默认命令行交互的时候都是以yes Linux 命令行下载文件，马上就能想到两个工具：wget 和 cURLcurl和wget的区别和使用curl和wget基础功能有诸多重叠，如下载等。非要说区别的话: curl由于可自定义各种请求参数所以在模拟web请求方面更擅长； wget由于支持ftp和Recursive所以在下载文件方面更擅长。类比的话curl是一个精简的命令行网页浏览器，而wget是迅雷9 wget不是安装方式，它是一种下载工具，类似于迅雷。通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理，名字是World Wide Web”与“get”的结合,如果要下载一个软件,可以直接运行： 1wget 下载地址 安装wget 123sudo apt-get update / yum updatesudo apt-get install wget / yum install wgetwget --version curlcurl的用法具体可以参考阮老师的教程，这里就不重复赘述了…curl 的用法指南 linux常用shell操作 1) &gt;和 &gt;&gt; linux中&gt;表示覆盖原文件内容，&gt;&gt;表示追加内容 2)cat 12345-n 或 --number：由 1 开始对所有输出的行数编号。// cat -n linuxfile1 &gt; linuxfile2 把 linuxfile1 的档案内容加上行号后输入 linuxfile2 这个档案里-b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。//cat -b linuxfile1 linuxfile2 &gt;&gt; linuxfile3 把 linuxfile1 和 linuxfile2 的档案内容加上行号(空白行不加)之后将内容附加到linuxfile3 里。-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。 查看已经存在的文件cat filename 新建文件 (只能创建新文件,不能编辑已有文件.)cat &gt; filename 合并副本(拷贝)cat sourcefile &gt; distfile 将几个文件合并为一个文件。cat file1 file2 &gt; file // file1 和file2都写入到file中 在linux shell脚本中我们经常见到类似于cat &lt;&lt; EOF的语句,EOF是文件的结束符-EOF是“end of file”，表示文本结束符,EOF只是一个标识符。可以换成别的标识。1234// 将EOF之间输入的内容写入到filename中 cat &gt; filename &lt;&lt;EOF （内容） EOF 1234// 将EOF之间输入的内容"追加写入"到filename中 cat &gt;&gt; filename &lt;&lt;EOF （内容） EOF 3)echo 在控制台输出文本echo xxxxx // 打印xxxxx 显示结果定向至文件echo xxxxx &gt; filename // xxxxx写入到filename中 4)touch touch命令用于创建不包含任何内容的文件touch xxxx 5)mv mv命令将文件或目录从一个位置移动到另一个位置mv sourcefile1 sourfile2 /etc/app 重命名mv sourcefile1 sourcefile2 6)pwd 命令用于打印当前工作目录 查看操作系统（uname -a）12uname -a // 可以查看操作系统 Linux master 3.10.0-862.el7.x86_64 #1 SMP Fri Apr 20 16:44:24 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 查看版本（cat /etc/redhat-release）1CentOS Linux release 8.0.1905 (Core) 所以根据上面的信息可以购买的华为云是Linux 64位的Centos 6.8版本 安装nodejs要安装nodejs，最通俗的做法无非是查看远程服务器的操作系统和版本，然后从nodejs官网下载,然后通过解压工具解压文件 使用上面说的wget/curl/手动官方下载1234// 使用curl下载curl -O http://cdn.npm.taobao.org/dist/node/v8.12.2/node-v8.12.2-linux-x64.tar.gz// 使用wget下载 wget http://cdn.npm.taobao.org/dist/node/v8.12.2/node-v8.12.2-linux-x64.tar.gz 解压gz文件- tar命令是类Linux中比较 常用的解压与压缩命令。123456// 基本用法tar -xzvf filename.tar.gz // 解压文件并拷贝到指定目录tar -xzvf filename.tar.gz -C destPath// --strip-components 1 去掉第一层文件夹tar --strip-components 1 -xzvf file.tar.gz -C /opt/webs/folder/ 当然也有uzip等方式可以解压zip后缀的压缩文件…以上就是将file.tar.gz文件解压到/opt/webs/folder/文件夹下 另外补充一句如果下载的文件需要–重命名/移动/复制的话可以使用 123移动文件：mv 文件名 移动目的地文件名 重命名文件：mv 文件名 修改后的文件名复制文件：cp 文件名路径 目标路径 nginx基本操作123nginx -s reload // 重启nginx start // 启动nginx stop //关闭 后台进程相关12netstat -apn | grep 3000 // 查看3000端口启动的进程 一般可以看见进程id和进程类型 如： 11321/nginx，11321就是进程id，nginx就是进程类型kill -9 进程id // 关闭后台进程 PS是LINUX下最常用的也是非常强大的进程查看命令ps命令将某个进程显示出来,grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。grep命令是查找,是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。中间的|是管道命令 是指ps命令与grep同时执行 1ps -ef | grep 3000 UID PID PPID C STIME TTY TIME CMD root 27391 2049 0 17:42 pts/0 00:00:00 grep 8089 具体含义如下： UID：程序被该 UID 所拥有 PID：就是这个程序的 ID PPID：则是其上级父程序的ID C ：CPU使用的资源百分比 STIME ：系统启动时间 TTY ：登入者的终端机位置 TIME：使用掉的CPU时间。 CMD：所下达的是什么指令 nohup做后台进程之前一直用pm2做进程守护，一般都是在线上环境,这次用nphup… 12// 使用nohup在指定的host和port启动并记录进程id在pidfile，记录日志到mockserver的log文件nohup json-server --host 172.21.24.22 --port 8088 ./db.json --routes ./router.json &gt; mockSever.log &amp; echo $! &gt; pidfile.txt 这样杀死进程的时候就可以通过 1kill -9 `cat pidfile.txt` 通过公网IP访问华为云服务上部署程序，部署成功之后，发现它的公网IP不能被外网访问,一直以为只能通过域名访问，但是域名也是通过DNS域名解析之后获取真实的公网ip地址啊，不应该啊，怀着这个疑问查了一下…. 原来云服务器需要添加一些配置，才可以通过公网ip访问部署的应用: 云服务器要添加安全协议 服务器要添加入站规则 我个人的理解就是需要开放云服务器各个端口的使用权限。配置一下哪些ip地址来请求可以访问我的云服务器，然后对它开发那些端口…类似这样的规则 如上图所示就是就是协议/应用选择TCP，输入你开放的端口号82，源地址选择IP地址，四个零，点击确定；为什么源地址选择IP地址，四个零，因为开放全部用户访问，然后就可以通过外网ip进行访问了….. 参考链接在华为云服务器部署程序不能被外网访问的问题]]></content>
      <categories>
        <category>水牛下水系列</category>
        <category>水牛下水系列（0）-  linux 基础及其服务器nginx静态资源部署</category>
      </categories>
      <tags>
        <tag>centOs</tag>
        <tag>Linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（2）- 处理http请求]]></title>
    <url>%2F2019%2F11%2F08%2Fnodejs-2%2F</url>
    <content type="text"><![CDATA[上一章节，我们搭建了nodejs的server端开发环境，本章节我们就开始对http请求做一些预处理… 本篇幅主要的技术点[❌] 使用node原生http模块搭建http-server[❌] 使用nodemon处理热加载[❌] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[✔] 使用querystring处理get请求的参数[✔] 使用promise的方式获取post请求body参数的获取[✔] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[❌] mySql常用操作汇总[❌] nodejs链接本地mysql数据库响应客户端请求[❌] 登陆校验/登陆信息存储[❌] nodejs链接redis数据库[❌] nginx的配置反向代理[❌] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） 模块拆分 bin/www.js为整个node应用的主入口，简称app,将app拆封成: 跟http-server相关的逻辑（只关注http-server本身的配置） 处理具体后台业务的serverHandler(req对象有req.method可以获取求情类型，req.url可以获取请求的url地址) 12345 //http-server 这里的逻辑和具体业务没有关系const serverHandler = require('./serverHandler') // 统一拦截路由，响应客户端的请求const http =require('http')const server = http.createServer((req,res)&#123;&#125;) ==== 抽离成==== &gt; const server = http.createServer(serverHandler)server.listen(3000) serverHandler预处理http的get请求:通过req.url和req.method可以分别获取浏览器客户端发送请求的地址信息和请求类型信息： 1234567891011// serverHandlerconst querystring = require('querystring')//------------------------- 第一步 处理返回数据的格式为json---------------------------------------------res.setHeader("Content-type","application/json") // 注意大小写//------------------------- 第二步 处理get请求的参数---------------------------------------------------// 解析path，然后赋值给req对象req.path = querystring.parse(req.url.split('?')[0]);// 引入querystring处理get请求的参数，然后赋值给req对象const querystring = require('querystring')req.query = querystring.parse(req.url.split('?')[1]); 设置http request请求头的content-type12// 获取请求头的content-typereq.headers['content-type','application/json'] // 注意大小写 通过promise的方式封装post请求获取body参数123456789101112131415161718192021//---------------------------第三步 通过promise的方式封装post请求获取body参数---------------------------// 因为post请求获取body的数据是异步的，所以用promise封装一下，方便后面处理代码执行逻辑，等获取到body后处理路由数据const getPostData=(req)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; if(req.method==='POST')&#123; let postData= '' // 类似stream流的方式获取body中的data req.on('data',chunk=&gt;&#123; postData += chunk.toString() &#125;) // 监听到完成返回数据 req.on('end',()=&gt;&#123; if(postData)&#123; resolve(postData) return &#125; resolve(&#123;&#125;) &#125;) &#125; &#125;)&#125; 根据业务处理路由123456789101112131415161718192021222324252627// ---------------------------第四步 引入路由处理，然后根据req请求的类型和参数类型处理不同的逻辑-------------------const blogRouterHandler = require('./src/router/blog')const userRouterHandler = require('./src/router/user') // 处理post请求异步的body中携带的数据getPostData(req).then(postData =&gt; &#123; // 将解析的body数据放入req的body中在路由中使用 req.body = postData; // 处理页面路由 const blogResult = blogRouterHandler(req, res); if (blogResult) &#123; blogResult.then(blogData=&gt;&#123; res.end(JSON.stringify(blogData)) return &#125;) &#125; const userData = userRouterHandler(req, res); if (userResult) &#123; userResult.then(blogData=&gt;&#123; res.end(JSON.stringify(userData)) return &#125;) &#125; // 处理异常路由 res.writeHead(404, &#123; 'content-Type': 'text/plain' &#125;) res.write('404 Not Fount \n'); res.end();&#125;); 处理响应数据的数据结构 serverHandler中，按照业务又拆分成：处理博客的相关路由/用户相关的路由/以及路由未命中的404异常 为了再响应客户端请求时，返回的数据能够格式统一，于是封装了一个responseModel。包括data,message和state三个参数这样响应的时候就能统一返回一个固定的格式： 12345678910111213141516171819202122232425262728293031323334353637// 基类class BaseModel&#123; constructor(data,message)&#123; if(typeof data =="String")&#123; this.message = data data = null message = null &#125; if(data)&#123; this.data =data &#125; if(message)&#123; this.message = message &#125; &#125;&#125;// 成功类class SuccessModel extends BaseModel&#123; constructor(data,message)&#123; super(data,message) this.state = 0 // 成功的状态 &#125;&#125;// 是败类class ErrorModel extends BaseModel&#123; constructor(data,message)&#123; super(data,message) this.state = -1 // 失败的状态 &#125;&#125;// 响应的示例： &#123; "data"："响应数据", "message":"这是响应的消息"， "state":"这是响应的状态" &#125; 封装api跟mysql数据库交互查询数据 在博客的相关路由和用户相关路由中又根据各自的业务，设计RestFul接口Api来处理具体的业务和数据返回,然后将api接口返回的数据通过SuccessModel进行包装。 123456789101112131415161718192021222324252627const &#123; SuccessModel, ErrorModel&#125; = require('../model/model')const &#123; getBlogList // 这就是从数据库查询数据的接口，需要用nodejs链接mysql数据库，然后封装查询的方法queryData&#125;= require('../api/blog')// blogRouterHandler.jsconst blogRouterHandler = (req,res)=&gt;&#123; // 列表 if(req.method === 'GET'&amp;&amp; req.path==="api/blog/list")&#123; // 需要封装getBlogList的api来获取博客列表 const blogListResult = getBlogList(req); if(blogListResult)&#123; return new SuccessModel(blogListResult,'请求博客列表成功') &#125; return ErrorModel('请求博客列表失败') &#125; // 创建 if(req.method === 'POST'&amp;&amp; req.path==="api/blog/create")&#123; // 需要封装createBlog的api来新增 &#125; ... &#125;module.exports = blogRouterHandler 总结到此位置，我们一步一步的剥离server端的功能，从app.js(搭建http服务和处理请求的serverHandlder)===&gt;serverHandler(预处理get/post请求，处理路由和异常的404，当然也可以处理cookie/session等)===&gt;router（根据业务拆分不同的路由）===&gt;api（在不同的路由中又根据不同的业务封装api和数据库交互）。看似很复杂，但是一步一步又很合理…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (2) - 处理http请求</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（2）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 山羊上山系列（1）- 搭建开发环境]]></title>
    <url>%2F2019%2F11%2F07%2Fnodejs-1%2F</url>
    <content type="text"><![CDATA[最近在看很早之前就看过的一个nodejs教程，主要是从零搭建一个前后台node项目的博客系统,在公交上通勤无聊就拿出来看看，当时看的比较粗，可能是工作上有了一些沉淀，这次看的时候发现了很多细节，例如为什么要这样切分模块，为什么要把业务逻辑进行抽离，怎么使用vscode进行nodejs程序的调试等。虽然很基础，但是还想记录一下，毕竟talk is cheap,能写下来或者给别人讲一遍，才说明自己真的明白了。所以记录一下这个过程… 前言我个人喜欢短小一些的博文，特别是长时间在通勤路上或者一些碎片的时间，我都喜欢看一些技术博客。长时间下来，我发现掘金啊，segment default上有一类博文我就特别钟爱：篇幅不长，内容切分成多个章节，一个章节只阐述一个或者一类的知识点，我不知道是不是写博客也是在遵守单一原则这样一方面我可能在10分钟看完一个内容,就可以去忙别的事情了，有一个commit的节点。再就是下次还可以接着看后面的内容，不需要回忆之前的内容，内容相对独立。所以这个系列，我也打算这样尝试一下，分成几个不同的章节，一个章节很简单的写一个内容… 本篇幅主要的技术点[✔] 使用node原生http模块搭建http-server[✔] 使用nodemon处理热加载[✔] 使用cross-env处理不同操作系统环境变量(通过nodejs的process全局变量的process.env.NODE_ENV就可以获取)[❌] 使用querystring处理get请求的参数[❌] 使用promise的方式获取post请求body参数的获取[❌] 使用es6 Class的方式定义响应数据的基础格式，然后对成功响应和失败响应extends基础格式[❌] mySql常用操作汇总[❌] nodejs链接本地mysql数据库响应客户端请求[❌] 登陆校验/登陆信息存储[❌] nodejs链接redis数据库[❌] nginx的配置反向代理[❌] 日志管理[❌] 信息安全（sql注入/xss攻击/md5信息加密） 初始化项目123456mkdir blog // 创建项目目录cd blog //进入项目目录npm init -y //初始化项目的package.json文件mkdir bin // 创建项目入口文件夹bintouch www.js // 创建项目的入口文件www.jsnpm install cross-env nodemon --save-dev 项目安装一些插件 cross-env适配window和macos等操作系统，设置环境变量 nodemon本地开发阶段帮你监听文件修改并热更新/线上环境常使用pm2来做进程守护和多线程任务，充分利用硬件的性能 这样就生成了一个项目的目录，现在我们修改一下package.json中项目的入口文件 1234567891011121314151617&#123; "name": "blog", "version": "1.0.0", "description": "", "main": "bin/www.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "cross-env NODE_ENV=dev nodemon bin/www.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "cross-env": "^6.0.3", "nodemon": "^1.19.4" &#125;&#125; 修改package.json中项目的主入口12345&#123; "script":&#123; "main":"bin/www.js" &#125;&#125; 设置环境变量 在package.json中使用cross-env设置NODE_ENV可以设置环境变量,然后再使用的地方可以根据nodejs提供的process全局变量上的process.env.NODE_ENV获取当前运行的环境变量 通常根据这个环境变量可以控制本地数据库和线上数据库，本地开发的ip和上线后部署服务器的ip等。 写npm脚本123"scripts": &#123; "dev": "cross-env NODE_ENV=dev nodemon bin/www.js"&#125; 使用nodejs起一个httpserver12345678910111213 // 第一步：引入http模块 const http= require('http') const PORT = 3000 ; // 可以将端口，api和模块前缀还有接口地址都配置在config文件中 // 第二步：创建一个httpserver const server = http.createServer((req,res)=&gt;&#123; // 逻辑 &#125;) // 从设计模式的角度，这里可以把处理逻辑按模块啊话切分成serverHandler，这个入口文件只负责起一个http-server，逻辑分离const serverHandler = require('./serverHandler.js')const server = http.createServer(serverHandler) // 第三步：监听端口 server.listen(PORT) console.log('server is running on port', PORT) vscode debug调试nodejs代码 配置debug的文件入口 在相应的代码中大断点就可以调试了 总结到此为止，我们就在不使用框架的前提下，搭建了一个http-server，可以通过cross-env设置NODE_ENV来配置nodejs内置的process.env.NODE_ENV环境变量，并且可以使用nodemon做本地开发时候的热更新;如果在开发过程中遇到问题，也可以使用vs-code内置的debug方式进行断点调试；这样一个简单的server开发环境就搭建好了…]]></content>
      <categories>
        <category>nodejs 山羊上山系列</category>
        <category>nodejs 山羊上山系列 (1) - 搭建开发环境</category>
      </categories>
      <tags>
        <tag>nodejs 山羊上山系列（1）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（9）- 组件通信路由传参]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-9%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（9）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第九种：通过router可以携带参数跳转页面的方式实现数据共享… 路由传参 vue router 一般传递参数有两种方式:通过this.$router.push的方式尽心路由跳转，然后再query和params参数中传递数据 注意:传参是this.$router,接收参数是this.$route,这里千万要看清了！！！ this.$router 和this.$route有何区别?在控制台打印两者可以很明显的看出两者的一些区别：1.$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法2.$route为当前router跳转对象，里面可以获取name、path、query、params等 query方式传参和接收参数 传递传参: 123456this.$router.push(&#123; path:'/xxx', query:&#123; id:id &#125;&#125;) 接收参数: 1this.$route.query.id params方式传参和接收参数 传递传参: 123456this.$router.push(&#123; name:'xxx', params:&#123; id:id &#125;&#125;) 接收参数: 1this.$route.params.id 注意: params传参，push里面只能是 name:’xxxx’,不能是path:’/xxx’,因为params只能用name来引入路由，如果这里写成了path，接收参数页面会是undefined！！！ 另外，二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示 页面刷新的话，query参数还在url里面存在，params参数就不存在了]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（9）- 组件通信路由传参</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（9）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（8）- 组件通信中央事件bus(eventBus)]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-8%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（8）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第八种：通过new Vue()实例的方式，在这个实力上通过事件广播和事件监听的方式完成跨组件中间件数据传输的方式实现数据共享… 中央事件总线Bus$emit/$on 这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。 具体实现方式123var Event=new Vue();Event.$emit(事件名,数据);Event.$on(事件名,data =&gt; &#123;&#125;); 全局定义事件Bus(类似vuex的顶层状态)12345678910// 在 main.jsVue.prototype.$eventBus=new Vue()// 传值组件this.$eventBus.$emit('eventTarget','这是eventTarget传过来的值')// 接收组件this.$eventBus.$on("eventTarget",v=&gt;&#123;console.log('eventTarget',v);//这是eventTarget传过来的值&#125;) 定义局部实例123456789101112131415161718// 在index.jsimport Vue from 'Vue';export const eventBus = new Vue()// 需要通讯的组件都import这个实例import eventBus from './index'export default &#123; data()&#123; $eventBus:eventBus &#125;&#125;// 传值组件this.$eventBus.$emit('eventTarget','这是eventTarget传过来的值')// 接收组件this.$eventBus.$on("eventTarget",v=&gt;&#123;console.log('eventTarget',v);//这是eventTarget传过来的值&#125;) 参考链接Vue 开发必须知道的 36 个技巧]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（8）- 组件通信中央事件bus(eventBus)</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（8）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（7）- 组件通信provide/inject]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-7%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（7）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第七种：通过provide/inject实现祖先组件数据可以被后代组件共享的方式实现数据通信… provide/inject(provide可以接受Object|()=&gt;{}) Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系 需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的—-vue官方文档 所以，上面 father.vue 的 userName 如果改变了，child.vue 的 this.name 是不会改变的，仍然是 pis。 基本核心用法123456789101112131415161718192021// father.vueexport default &#123; provide: &#123; name: this.userName &#125;, data()&#123; return&#123; userName:'pis' &#125; &#125;, mounted()&#123; this.userName = "uncle" // 父组件改了userName，但是传给子孙组件inject还是pis &#125;&#125;// child.vueexport default &#123; inject: ['name'], mounted () &#123; console.log(this.name); // pis &#125;&#125; provide与inject 怎么实现数据响应式provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods使用2.6最新API Vue.observable 优化响应式 provide(推荐) provide父组件的this实例对象(有多余没有用的参数) 123456789101112131415161718192021222324252627282930313233343536 // father 组件&lt;div&gt; &lt;h1&gt;fahter 组件&lt;/h1&gt; &lt;button @click="() =&gt; changeColor()"&gt;改变color&lt;/button&gt; &lt;ChildrenB /&gt; &lt;ChildrenC /&gt; provide父组件的color：&#123;&#123;color&#125;&#125;&lt;/div&gt;......data() &#123; return &#123; color: "blue" &#125;;&#125;,// provide() &#123; // return &#123; // theme: &#123; // color: this.color //这种方式绑定的数据并不是可响应的 // &#125; // 即father组件的color变化后，组件childrenB,childrenC不会跟着变 // &#125;;// &#125;,provide() &#123; return &#123; theme: this//方法一：提供祖先组件的实例 &#125;;&#125;,methods: &#123; changeColor(color) &#123; if (color) &#123; this.color = color; &#125; else &#123; this.color = this.color === "blue" ? "red" : "blue"; &#125; &#125;&#125; 使用新特性 123456789101112131415161718// 方法二:使用2.6最新API Vue.observable 优化响应式 provide provide() &#123; const provideData= Vue.observable(&#123; color: this.$data // 使用observable包装后就动态响应式 &#125;); return &#123; theme: provideData.color // 这样就可以监听到数据的变化了 &#125;; &#125;, methods: &#123; changeColor(color) &#123; if (color) &#123; this.theme.color = color; &#125; else &#123; this.theme.color = this.theme.color === "blue" ? "red" : "blue"; &#125; &#125; &#125; ComponentB或者ComponentC的组件中使用 1234567891011121314151617 // 子孙组件中使用&lt;template functional&gt;&lt;div class="border2"&gt;&lt;h3 :style="&#123; color:theme.color &#125;"&gt;ComponentB或者ComponentC的组件中使用&lt;/h3&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; inject:['theme'], // 引入父组件provide的this实例 inject: &#123; theme: &#123; //函数式组件取值不一样 default: () =&gt; (&#123;&#125;) &#125; &#125;&#125;;&lt;/script&gt; 参考链接Vue 组件间通信六种方式Vue 开发必须知道的 36 个技巧]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（7）- 组件通信provide/inject</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（7）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（6）- 组件通信$attrs/$listeners]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-6%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（6）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第六种：通过$attrs/$listeners获取没有在组件props属性中声明的属性和绑定在组件上的事件对象的方式完成数据通信… $attrs/$listeners$attrs$attrs传值时是不会传递class和style以及已经被props接收的值的场景:如果父传子有很多值,那么在子组件需要定义多个 props解决:attrs获取子传父中未在 props 定义的值 father ===&gt; child ===&gt; grand-child 这种组件props下发 通过在child组件中定义需要给child组件的width属性 $attrs就剩下需要传给grand-child孙子组件的数据 没有定义native的非原生事件会被$listeners层层传递 1234567// 父组件&lt;child title="这是标题" width="80" height="80" imgUrl="imgUrl"/&gt;// 子组件mounted() &#123; console.log(this.$attrs) //&#123;title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"&#125;&#125;, 相对应的如果子组件定义了 props,打印的值就是剔除定义的属性 12345678910111213// child组件&lt;template&gt; &lt;grand-child :attrs="$attrs"/&gt;&lt;/template&gt;props: &#123; width: &#123; // --------------------定义了width type: String, default: '' &#125;&#125;,mounted() &#123;console.log(this.$attrs) //&#123;title: "这是标题", height: "80", imgUrl: "imgUrl"&#125; $attrs里面就没有width了&#125; $listeners$listeners里存放的是父组件中绑定的非原生事件 使用.native修饰符的事件，不会体现在$listeners属性上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// father组件（App.vue）&lt;template&gt; &lt;div id="app"&gt; &lt;child :username="username" :age="age" v-on:test1="onTest1" v-on:test2="onTest2"&gt; //此处监听了两个事件，可以在B组件或者C组件中直接触发 &lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './Child.vue';export default &#123; data() &#123; return &#123; username:'pis', age:18, job:'developer' &#125;; &#125;, components: &#123; Child &#125;, methods: &#123; onTest1() &#123; console.log('test1 running...'); &#125;, onTest2() &#123; console.log('test2 running'); &#125; &#125;&#125;;&lt;/script&gt;// children组件（Child.vue）&lt;template&gt; &lt;div class="child"&gt; &lt;p&gt;in child:&lt;/p&gt; &lt;p&gt;props: &#123;&#123;userName&#125;&#125;&lt;/p&gt; // pis &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; // 18 developer &lt;hr&gt; &lt;!-- grandChild组件中能直接触发test的原因在于 child组件调用grandChild组件时 使用 v-on 绑定了$listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定$attrs属性，grandChild组件可以直接获取到father组件中传递下来的props（除了child组件中props声明的） --&gt; &lt;grand-child v-bind="$attrs" v-on="$listeners" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import grandChild from './grandChild.vue';export default &#123; props: ['userName'], data() &#123; return &#123;&#125;; &#125;, inheritAttrs: false, components: &#123; grandChild &#125;, mounted() &#123; this.$emit('test1'); // 这里触发test1的事件在father组件中打印 &#125;&#125;;&lt;/script&gt;// grandChild 组件 (grandChild.vue)&lt;template&gt; &lt;div class="grandChild"&gt; &lt;p&gt;in grandChild:&lt;/p&gt; &lt;p&gt;props: &#123;&#123;age&#125;&#125;&lt;/p&gt; // 18 &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;/p&gt; // developer &lt;hr&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['age'], data() &#123; return &#123;&#125;; &#125;, inheritAttrs: false, mounted() &#123; this.$emit('test2'); // 这里通过$listeners获取到test1和test2的事件，触发test2的事件在father组件中打印 &#125;&#125;;&lt;/script&gt; 参考链接Vue 新增的$attrs与$listeners的详解Vue 开发必须知道的 36 个技巧]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（6）- 组件通信$attrs/$listeners</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（6）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（5）- 组件通信$parent/$children,$refs/$root获取Vue组件实例]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-5%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（5）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第三、四、五：通过$parent/$children,$refs/$root获取组件实例，从而获取实例上绑定的属性和方法… $parent / $children与 ref ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素;如果用在子组件上，引用就指向组件实例 $parent / $children：访问父 / 子实例 $root获取根实例 兄弟组件通信就不是很方便了,可能要借助eventBus或者顶层状态vuex来进行通信… ref 注意定义的时候使用的是ref 在组件里面用的时候是$refs[‘refName’]获取组件的vue实例 123456789101112131415161718192021222324252627 // component-a 子组件 export default &#123; data () &#123; return &#123; title: 'Vue.js' &#125; &#125;, methods: &#123; sayHello () &#123; window.alert('Hello') &#125; &#125; &#125; // 父组件 &lt;template&gt; &lt;component-a ref="comA"&gt;&lt;/component-a&gt; &lt;/template&gt; &lt;script&gt; export default &#123; mounted () &#123; const comA = this.$refs.comA; console.log(comA.title); // Vue.js comA.sayHello(); // 弹窗 &#125; &#125;&lt;/script&gt; $parent:父实例/$children:子实例 注意children和parent是父链/子链,也就是如果是多层级的话可以通过this.$parent[0].$parent[1]…这种链式的方式一直获取组件链上的实例对象，但是不保证顺序。 1234567891011//父组件 mounted()&#123; console.log(this.$children) //可以拿到 一级子组件的属性和方法 //所以就可以直接改变 data,或者调用 methods 方法 &#125; //子组件 mounted()&#123; console.log(this.$parent) //可以拿到 parent 的属性和方法 &#125; $root 最后所有组件都是挂载到根实例上 123456 // 父组件mounted()&#123; console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上 console.log(this.$root.$children[0]) //获取根实例的一级子组件 console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件&#125;]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（5）- 组件通信$parent/$children,$refs/$root获取Vue组件实例</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（5）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（3）- 组件通信props、$emit/$on]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-3%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（3）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第一种：props、$emit/$on的方式进行数据的属性下发和事件广播/监听的方式进行接收… 父传子props/子传父$emit发送事件$on监听 这也是最常规的通信方式，如果跨层级也可以一层一层传递下发props，然后一层一层emit事件通过监听获取子组件的数据. props的配置项1234567891011121314151617181920212223242526272829303132333435363738394041424344// children.vue子组件// props:['props1Name','props2Name',], 不建议这么写 props:&#123; props1Name:&#123; type:'String', // props类型 String/Number/Boolean/Function/Object/Array/Symbol required:false, // 是否必填 default:'props1', // 默认参数 &#125;, //对象或数组的默认值必须从一个工厂函数返回。当一个函数返回一个对象时，我们称之他为 工厂函数(factory function) 。 props2Name:&#123; type:'Object', default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 props3Name: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125;， // 函数 props4Name: &#123; type:Function, default:()=&gt;&#123;&#125; &#125;， // 数组 props5Name: &#123; type: Array, // 对象或数组默认值必须从一个工厂函数获取 default: () =&gt; [] &#125; &#125;,// 组件绑定的属性 // 父组件father.vue &lt;div&gt; &lt;p&gt;我是父组件&lt;p&gt; &lt;children :props1Name="props1Name" :props2Name="props2Name" :props3Name="props3Name" :props4Name="props4Name" :props5Name="props5Name" /&gt; &lt;/div&gt; 需要注意的点:props传递是单向的，只能从父组件流到子组件,所以不能直接在子组件中修改props的值(可以通过计算属性将props通过get/set存储成子组件的局部变量,然后修改使用)12345678910111213141516171819202122232425262728293031// 父组件&lt;children :isShow="isShow" /&gt;// 子组件中&lt;template&gt; &lt;Modal v-model="showModal" @on-cancel="closeModal"&gt; &lt;/Modal&gt;&lt;/template&gt;export default&#123; props:&#123; isShow:&#123; type:Boolean, required:true, default:false &#125; &#125;, computed:&#123; showModal:&#123; get()&#123; return this.isShow &#125;, set(val)&#123;&#125; &#125; &#125;, methods:&#123; closeModal()&#123; this.showModal = false; &#125; &#125;&#125; $emit123456789// father.vue&lt;children @emitEventName ="emitEventHandler" /&gt;emitEventHandler(event)&#123; // 可以接收发过来的参数，默认是事件对象&#125;// children.vuethis.$emit('emitEventName');// $event默认参数传递事件对象this.$emit('emitEventName',params);//可以传递params参数]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（3）- 组件通信props、$emit/$on</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（3）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（4）- 组件通信vuex]]></title>
    <url>%2F2019%2F10%2F19%2Fvue-4%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（4）主要收录的就是vue组件间通信的几种方式，如1.props、$emit/$on2.vuex3.$parent/$children4.$refs5.$root6.$attrs/$listeners7.provide/inject8.中央事件bus(eventBus)9.路由传参 本文主要阐述第二种：vuex的方式进行多组件数据通信… vuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex具有以下特点：全局Vuex类似于一个全局变量，它在整个Vue应用中生效。 统一只要状态修改，都会自动通知到所有相关组件，不需要使用者主动推送。 单一在全局中只需要保存一份，即可在全局中使用。 Vuex解决了哪些问题：数据跨组件共享，数据的传输不再受到父子级限制，可以在各级组件中任意获取。防止数据被意外篡改，Vuex会记录数据被修改的详细信息，如修改状态的组件、时间、代码位置等，便于定位和追踪错误，同时也方便了调试和测试。 简单的说就是store里面存储的state是想要在跨多层级多组件共享的数据==》根据业务拆分成module不同的模块独立维护自己的顶层状态==》为了state维护，提高了修改它的门栏，只能通过$commit一个mutation触发state的修改==&gt;通过触发同步或者异步的action来commit一个mutation来修改state。 这个Flux的单项数据流和react的redux思想其实是一样的。 Vuex 基本概念：state:定义存贮数据的仓库 ,可通过this.$store.state 或mapState访问 getter:获取 store 值,可认为是 store 的计算属性,可通过this.$store.getter 或mapGetters访问 action:异步调用函数执行mutation,进而改变 store 值,可通过 this.$dispatch或mapActions访问 mutation:同步改变 store 值,为什么会设计成同步,因为mutation是直接改变 store 值,vue 对操作进行了记录,如果是异步无法追踪改变.可通过mapMutations调用 modules:模块,如果状态过多,可以拆分成模块,最后在入口通过…解构引入 Vuex的使用先使用vue-cli创建一个项目，之后使用npm install vuex –save安装Vuex，就可以在/src/main.js中配置Vuex：1234567891011121314151617181920212223242526272829303132333435// 1. vuex-引入import Vuex from 'vuex'// vue-cli自带的编译配置Vue.config.productionTip = false// 1. vuex-在Vue中使用Vuex，让Vuex中的操作挂载到Vue中。Vue.use(Vuex)// 3. vuex-声明store对象const store = new Vuex.Store(&#123; strict: process.env.NODE_ENV !== 'production', // 严格模式：防止直接修改state，只能用Mutations操作，由于strict模式是通过对象深度匹配进行，生产模式打开会严重影响性能。 state: &#123;&#125;, // 核心：数据 mutations: &#123; // 定义Mutations &#125;, actions: &#123; // 定义actions &#125;, getters: &#123; a: state =&gt; state.app.a, b: state =&gt; state.app.b, fullName:state=&gt; `$&#123;state.user.firstName&#125; $&#123;state.user.lastName&#125;` // 当然也可以跨模块数据通过计算属性来组合 &#125;, // 类似于computed modules: &#123; app &#125; // 将store拆分成多个命名空间，分开使用。&#125;)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, // 将store挂载到Vue实例中。 components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 读取state的值12345678// 在Index.vue中可以通过$store.state.a读取到已定义的a的值。&lt;template&gt; &lt;div&gt; &lt;Cmp1/&gt; // 读取Vuex的state a: &#123;&#123; $store.state.a &#125;&#125; &lt;/div&gt;&lt;/template&gt; 修改state的值 可以通过commit一个mutation修改state 可以通过dispatch一个action触发mutation来修改state 1234567891011121314//定义Actions和Mutationsconst app = &#123; state: &#123;a: 12, b: 5&#125;, // 核心：数据 mutations: &#123; // 定义Mutations，通过action触发并更新state，Vue Devtool可以监听到数据的修改情况。 add (state, n) &#123; // 第一个参数为旧state，第二个参数为action中commit传入的参数。 state.a += n &#125; &#125;, actions: &#123; // 定义actions，actions被触发后，将数据提交给Mutations进行处理并更新state。 add (&#123; commit &#125;, n) &#123; // 第一个参数为context对象，它不是store本身，可以通过context.commit提交一个Mutation。第二个参数为用于更新state的参数。 commit('add', n) &#125; &#125;&#125; 12345678910111213141516171819202122 // 接下来实现在Cmp1.vue组件中，点击按钮后修改state中的a的值 &lt;template lang="html"&gt; &lt;div class=""&gt; &lt;input type="button" value="+5" @click="fn()"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: 'cmp1', methods: &#123; fn()&#123; // this.$store.state.a+=5; // 在严格模式下，直接修改state可以成功，但会报错 // this.$store.commit('add', 5); // 直接触发一个Mutation其实也可行，且不会报错，但这其实违背了Vuex设计的初衷。 this.$store.dispatch('add', 5); // 触发一个action，实现数据修改。 &#125; &#125; &#125;&lt;/script&gt;&lt;style lang="css" scoped&gt;&lt;/style&gt; vuex辅助函数mapGetters/mapState/mapActionGetter的基本使用（this.$store.getters.count）Vuex中的Getter的作用类似于Vue中的Computed，可以实现在state变化时自动计算出一个新的结果。 在store中配置一个Getter： 12345678modules:&#123; // 假如有两个模块 firstNameModule, lastNameModule&#125;,getters: &#123; fullName:state=&gt; `$&#123;state.firstNameModule.firstName&#125; $&#123;state.lastNameModule.lastName&#125;` // 当然也可以跨模块数据通过计算属性来组合&#125; 在组件中，可以通过$store.getters.count就可以读取到相应的值。： 1&lt;div&gt;count from getters: &#123;&#123;$store.getters.count&#125;&#125;&lt;/div&gt; 为了方便使用，通常可以把Getter配置到Computed中 12345computed: &#123; countFromComputed() &#123; return this.$store.getters.count &#125;&#125; 在Template中引用 1&lt;div&gt;count from computed: &#123;&#123;countFromComputed&#125;&#125;&lt;/div&gt; 利用Computed的get/set更新State：因为Computed属性支持get和set方法，所以能够使用set方法更新State。1234567891011121314151617// 首先在Store中设置actions和Mutations。 mutations: &#123; addA (state, n) &#123; state.a += n &#125;, addB (state, n) &#123; state.b += n &#125;,&#125;,actions: &#123; addA (&#123;commit&#125;, n) &#123; commit('addA', n) &#125;, addB (&#123;commit&#125;, n) &#123; commit('addB', n) &#125;,&#125;, 在计算属性的set中触发action或者commit触发mutation修改state 12345678countFromComputedSet: &#123; get() &#123; return this.$store.getters.count &#125;, set(value) &#123; this.$store.dispatch('addA', 5) &#125;,&#125;, map映射函数 mapState的使用 首先需要引入map函数 1import &#123; mapState, mapActions, mapGetters &#125; from 'vuex' 在computed中使用mapState： 123computed: &#123; ...mapState(['a', 'b']),&#125; 就可以代替这段代码 12345678computed: &#123; a() &#123; return this.$store.state.a &#125;, b() &#123; return this.$store.state.b &#125;, &#125; mapActions的使用 在methods中添加addA和addB的映射 123methods: &#123; ...mapActions(['addA', 'addB']),&#125;, 等价于 12345678methods: &#123; addA(n) &#123; this.$store.dispatch('addA', n) &#125;, addB(n) &#123; this.$store.dispatch('addA', n) &#125;, &#125; mapGetters的使用 在computed中添加count的映射： 123computed: &#123; ...mapGetters(['count'])&#125; 等价于 12345computed: &#123; count() &#123; return this.$store.getters.count &#125;&#125; 也可以 123methods: &#123; ...mapGetters(['count'])&#125; 等价于 12345methods:&#123; count()&#123; return this.$store.getters.count &#125;&#125; 参考链接Vuex入门Vuex GettermapState、mapActions、mapGetters]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（4）- 组件通信vuex</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（4）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（2）- vue组件化]]></title>
    <url>%2F2019%2F10%2F08%2Fvue-2%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（2）主要收录的就是vue的组件化部分的内容,简单描述一下一个vue实例或者说是组件内部包含哪些配置项目… 组件化Vue组件 = Vue实例 = new Vue(option) 其实vue组件就是一个个不同option配置的vue实例。123456789101112// 用法&lt;component-demo // 一般在html中使用分割 name="Hello Vue！" // 原生属性 :type="type" :is-visible="false" :on-change="handlePropChange" title="属性Demo" // 原生属性 class="test1" // 原生属性 :class="['test2']" // 这种写法等价于class="test2" :style="&#123; marginTop: '20px' &#125;" style="margin-top: 10px" // 原生属性/&gt; 配置组件的option1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var vueInstant = new Vue(&#123; name:'componentDemo', // 组件名称 非必填，js中使用小驼峰,在使用递归组件的时候必填 inheritAttrs: false, // 没有声明的属性是否再组件的根节点自动挂载，默认是true // props:['props1Name','props2Name',], 不建议这么写 props:&#123; props1Name:&#123; type:'String', // props类型 String/Number/Boolean/Function/Object/Array/Symbol required:false, // 是否必填 default:'props1', // 默认参数 &#125;, //对象或数组的默认值必须从一个工厂函数返回。当一个函数返回一个对象时，我们称之他为 工厂函数(factory function) 。 props2Name:&#123; type:'Object', default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 props3Name: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125;， // 函数 props4Name: &#123; type:Function, default:()=&gt;&#123;&#125; &#125;， // 数组 props5Name: &#123; type: Array, // 对象或数组默认值必须从一个工厂函数获取 default: () =&gt; [] &#125; &#125;,// 组件绑定的属性 el:"#app", // vueInstant.$mount('#app') data:&#123; // 视图和数据进行了响应 content:'hello world' &#125;, filters:&#123; // 自定义过滤器 filterItem(item)&#123; return item.toLowerCase() &#125; &#125;, computed:&#123; // 计算属性 isValid()&#123; return this.props1Name=='hello world' &#125;, newContent:&#123; get:function()&#123; return this.content.split('').reverse().join('') &#125;, set:function(newValue)&#123; // 修改了计算属性的setter方法可以接受到新的值 &#125; &#125; &#125;,&#125;);－只有当组件实例的时候存在的属性才会触发视图的响应更新－未来产生的属性需要在实例的时候初始化－object.freeze(obj)会阻止修改现有的属性，也就不会触发视图的响应 2.组件的组成 - 属性：自定义的动态属性props/原生属性attrs/特殊的属性class/style 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; // 和`v-bind:class`一样的 API 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API style: &#123; color: 'red', fontSize: '14px' &#125;, // 正常的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅对于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意事项：不能对绑定的旧值设值 // Vue 会为您持续追踪 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // Scoped slots in the form of // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef'&#125; 组件的分类:全局组件1通过Vue.component('componentName',&#123;ConfigOption&#125;)的方式全局注册。 局部组件1234567891011121314151617181920// 定义一个组件internalComponent.vueexport default&#123; name:'internalComponent', ...&#125; &lt;template&gt;&lt;internal-component /&gt;&lt;/template&gt;// 使用时候import并且局部注册&lt;script&gt;import internalComponent from './internalComponent.vue'export default&#123; name:'parentComponent', components：&#123; internalComponent // 局部注册 &#125; ...&#125;&lt;/script&gt; 动态组件12345678910111213141516171819202122232425262728&lt;template&gt; &lt;component :is="dynamicComponentName" /&gt; &lt;button @click="handleChangView('A')"&gt;切换到A&lt;/button&gt; &lt;button @click="handleChangView('B')"&gt;切换到B&lt;/button&gt; &lt;button @click="handleChangView('C')"&gt;切换到C&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import componentA from './componentA.vue' import componentB from './componentB.vue' import componentC from './componentC.vue' export default&#123; components:&#123; componentA, componentB, componentC, &#125;, data()&#123; return&#123; dynamicComponentName:'componentA' &#125; &#125;, methods:&#123; handleChangView(val)&#123; this.dynamicComponentName = `component$&#123;val&#125;` &#125; &#125; &#125;&lt;/script&gt; 当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题.重新创建动态组件的行为通常是非常有用的，如果更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 元素将其动态组件包裹起来。 123&lt;keep-alive&gt; &lt;component :is="dynamicComponentName"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 函数式组件什么是函数式组件我们可以把函数式组件想像成组件里的一个函数，入参是渲染上下文(render context)，返回值是渲染好的HTML对于函数式组件，可以这样定义： * Stateless(无状态)：组件自身是没有状态的 * Instanceless(无实例)：组件自身没有实例，也就是没有this 定义一个函数式组件就像这样： 1234567891011121314151617// Vue.component('my-component', &#123; functional: true, // Props 是可选的,你可以省略 props 选项，所有组件上的特性都会被自动隐式解析为 prop props: &#123; // ... &#125;, // 为了弥补缺少的实例 // 提供第二个参数作为上下文 render: function (createElement, context) &#123; // ... &#125;&#125;)//如果你使用了单文件组件，那么基于模板的函数式组件可以这样声明：&lt;template functional&gt;&lt;/template&gt; 就像上文所讲的，函数式组件没有this，参数就是靠context来传递的了，下面我们看下context有哪些属性呢 * props:提供所有 prop 的对象 * children * slots (a slots object) * parent * listeners * injections * data 递归组件组件在它的模板内可以递归的调用自己，只要给组件设置name组件就可以了,不过需要注意的是，必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded 1234567891011121314151617181920212223&lt;template&gt; &lt;div v-for="(item,index) in treeArr"&gt; 子组件，当前层级值： &#123;&#123;index&#125;&#125; &lt;br/&gt; &lt;!-- 递归调用自身, 后台判断是否不存在改值 --&gt; &lt;tree :item="item.arr" v-if="item.flag"&gt;&lt;/tree&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; // 必须定义name，组件内部才能递归调用 name: 'tree', data()&#123; return &#123;&#125; &#125;, // 接收外部传入的值 props: &#123; item: &#123; type:Array, default: ()=&gt;[] &#125; &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（2）- vue组件化</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（2）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 朝花夕拾系列（1）- vue内置指令和修饰符基础]]></title>
    <url>%2F2019%2F10%2F08%2Fvue_1%2F</url>
    <content type="text"><![CDATA[vue 朝花夕拾系列（1）主要收录的就是vue使用中的基础知识,包括：vue的特点,模板技术, key实现组件高效复用,双向数据绑定及其语法糖,vue的内置指令和vue的事件修饰符等内容… vue 特点介绍 提供了virtual dom的虚拟dom 提供了响应式呵呵组件化的视图组件 渐进式框架，将注意力集中保持在核心库上，而将其他功能如理由vue-router和全局的状态管理vuex交给相关的库进行管理。 由于vue的响应式是基于Object.defineProperty的getter和setter,而这个是仅仅支持es5的，所以vue不支持ie8以及更低版本的浏览器。 vue使用了Mustache的html模板技术: 即双大括号，来声明式地将dom绑定至vue实例的数据，双大括号中支持javascript表达式，但是不支持逻辑代码块或者代码片段。 12345671)&#123;&#123;&#125;&#125;类似angularjs,在dom中使用双括号进行变量插值,经常适用于非html属性&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;2) html的属性需要使用v-bind的方式进行绑定&lt;div id="app" :title="title"&gt;&lt;/div&gt; // title是data对象中的动态值&lt;div id="app" title="我是静态属性"&gt;&lt;/div&gt; // 静态属性直接字符串写入属性,不需要bind 使用key复用123456789101112// vue会高效复用组件元素，所以需要根据场景使用key标识是否复用&lt;div&gt; &lt;input v-if="true" placeholder="uncle"/&gt; &lt;input v-if="false" placeholder="pis"/&gt;&lt;/div&gt;// 以上在条件渲染的时候只有placehodler不一样，所以会复用，如果需要重新渲染，需要加入key&lt;div&gt; &lt;input v-if="true" placeholder="uncle" key="firstName"/&gt; &lt;input v-if="false" placeholder="pis" key="lastName"/&gt;&lt;/div&gt; 数据双向绑定v-model(语法糖) v-model实际上是v-on:input和v-bind:value的语法糖。 v-bind可以缩写成:bind,而v-on:eventName可以缩写成@eventName12345它能轻松实现表单输入和应用状态之间的双向绑定。&lt;input v-model="userName"/&gt; // 等价于下面的写法&lt;input v-bind:value="userName" v-on:input="userName=$event.target.value"/&gt;&lt;input :value="userName" @on:input="userName=$event.target.value"/&gt;&lt;p&gt;&#123;&#123;userName&#125;&#125;&lt;/p&gt; 指令系统：带有v-前缀的特殊属性。1234567891011121314151617181920212223241.v-if: 控制节点的渲染和移除(惰性的，初始渲染的时候为真才渲染)2.v-show：控制节点的隐藏和消失（一直会渲染，只是切换css进行隐藏和消失）3.v-for:循环渲染，必须指定唯一的key(string或者number类型) 1) v-for循环数组：`v-for="(item,index) in items"` 2) v-for循环对象：`v-for="(value,key,index) in items"` ,遍历对象的时候多一个第三个参数的index 3) v-for循环数字：v-for="n in 10" ，注意遍历数字的时候n从1开始4.v-bind:attrName 属性绑定(可以简写成:attrName)5.v-on:eventName(argument1,$event) 事件监听 1)监听事件触发一些js的代码： &lt;button v-on:click="counter += 1"&gt;Add 1&lt;/button&gt; 2)逻辑太复杂的时候调用一个函数： &lt;button v-on:click="greet"&gt;Greet&lt;/button&gt; // $event默认可以省略 greet(event)&#123; // event就是原生 DOM 事件 &#125; 3)有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： &lt;button v-on:click="greet('hello',$event)"&gt;Greet&lt;/button&gt; // 显示的话必须使用特殊的$event指代原生的event对象 greet: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125; 修饰符 修饰符可以同时使用多个,但是可能会因为顺序而有所不同。用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。也就是从左往右判断~ 表单修饰符 .lazy 12345&lt;!--输入完所有东西，光标离开才更新视图,相当于在onchange事件触发更新 --&gt;&lt;div&gt; &lt;input type="text" v-model.lazy="value"&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;/div&gt; .trim 123&lt;!-- 过滤首尾的空格！首尾，中间的是不会过滤的 --&gt;&lt;input type="text" v-model.trim="value"&gt;// " 123 4 " ==&gt; "123 4" .number 123//如果你先输入数字，那它就会限制你输入的只能是数字。//如果你先输入字符串，那它就相当于没有加.number&lt;input type=&quot;text&quot; v-model.number=&quot;value&quot;&gt; 事件修饰符 stop 1234&lt;!-- 阻止事件冒泡,event.stopPropagation(),popUp(2)不会执行 --&gt;&lt;div @click="popUp(2)"&gt; &lt;button @click.stop="popUp(1)"&gt;ok&lt;/button&gt;&lt;/div&gt; prevent 12&lt;!-- 阻止事件冒泡,event.preventDefault() --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; self 1234&lt;!-- 只当事件是从事件绑定的元素本身触发时才触发回调 --&gt;&lt;div class="blue" @click.self="popUp(2)"&gt; &lt;button @click="popUp(1)"&gt;ok&lt;/button&gt;&lt;/div&gt; once 12&lt;!-- 绑定了事件以后只能触发一次，第二次就不会触发 --&gt;&lt;button @click.once="popUp(1)"&gt;ok&lt;/button&gt; .native 我们经常会写很多的小组件，有些小组件可能会绑定一些事件，但是，像下面这样绑定事件是不会触发的1&lt;My-component @click="popUp(3)"&gt;&lt;/My-component&gt; 必须使用.native来修饰这个click事件（即&lt;My-component @click.native=&quot;popUp(3)&quot;&gt;&lt;/My-component&gt;），可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，注意：使用.native修饰符来操作普通HTML标签是会令事件失效的 capture 123456789101112131415 &lt;!-- 其实完整的事件机制是：捕获阶段--目标阶段--冒泡阶段。默认的呢，是事件触发是从目标开始往上冒泡，加上capture就是从事件捕获阶段触发 --&gt; &lt;div @click.capture="popUp(1)"&gt; &lt;!--捕获阶段触发--&gt; 太爷爷层 &lt;div @click.capture="popUp(2)"&gt; &lt;!--捕获阶段触发--&gt; 爷爷层 &lt;div @click="popUp(3)"&gt; &lt;!--冒泡阶段触发--&gt; 爸爸层 &lt;div @click="popUp(4)"&gt; &lt;!--目标阶段触发--&gt; 自己层 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 太爷爷=&gt;爷爷层=&gt;自己层=&gt;爸爸层--&gt; passive v-on:event.passive:这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。.passiv修饰符尤其能够提升移动端的性能```1234567891011121314- 这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。- 我们通过passive将内核线程查询跳过，可以大大提升滑动的度。- passive和prevent冲突，不能同时绑定在一个监听器上。不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。- 请记住，.passive 会告诉浏览器你不想阻止的默认行为。- `passive和prevent的关系````html &lt;!-- 不加 prevent 修饰符 --&gt; &lt;a @click=&quot;clickFunc&quot; href=&quot;javascript:alert(&apos;default active&apos;)&quot;&gt;点击&lt;/a&gt; &lt;!-- 点击后 执行 clickFunc 事件函数，并提示default active --&gt; &lt;!-- prevent 修饰符 --&gt; &lt;a @click.prevent=&quot;clickFunc&quot; href=&quot;javascript:alert(&apos;default active&apos;)&quot;&gt;点击&lt;/a&gt; &lt;!-- 点击后 执行 clickFunc 事件函数，并没有提示default active --&gt; 鼠标按键修饰符 left 左键点击 right 右键点击 middle 中键点击 12&lt;!-- 刚刚我们讲到这个click事件，我们一般是会用左键触发，有时候我们需要更改右键菜单啥的，就需要用到右键点击或者中间键点击，这个时候就要用到鼠标按钮修饰符 --&gt; &lt;button @click.right="popUp(1)"&gt;ok&lt;/button&gt; 键值修饰符 .keyCode 12&lt;!-- 指定按下某一个键才触发这个popUp的时候，这个修饰符就有用了 --&gt; &lt;input type="text" @keyup.keyCode="popUp(4)"&gt; 为了方便我们使用，vue给一些常用的键提供了别名 123456789101112131415161718192021//普通键.enter .tab.delete //(捕获“删除”和“退格”键).space.esc.up.down.left.right//系统修饰键(需要将系统修饰键和其他键码链接起来使用).ctrl.alt.meta.shift&lt;input type="text" @keyup.ctrl.87="popUp(4)"&gt;// 可以通过全局 config.keyCodes 对象自定义按键修饰符别名：// 可以使用 `v-on:keyup.open`Vue.config.keyCodes.open = 123 如果是鼠标事件，那就可以单独使用系统修饰符 1&lt;button @mouseover.ctrl="popUp(1)"&gt;ok&lt;/button&gt; 单手指使用系统修饰键的修饰符（最少两个手指，可以多个）。你可以一个手指按住系统修饰键一个手指按住另外一个键来实现键盘事件。也可以用一个手指按住系统修饰键，另一只手按住鼠标来实现鼠标事件 v-bind修饰符 .sync(2.3.0+ 新增) 123456789101112//父亲组件&lt;comp :myMessage="message" @update:myMessage="func"&gt;&lt;/comp&gt;//jsfunc(msg)&#123; this.message = msg;&#125;//子组件js发送事件更新父组件的messageinvokerFunction()&#123; this.$emit('update:myMessage',params);&#125; 可以简化成 12345&lt;!-- 父组件使用sync修饰符简化上面的写法 --&gt; &lt;comp :myMessage.sync="message"&gt;&lt;/comp&gt; //子组件invoker的函数触发事件 this.$emit('update:myMessage',params); sync需要注意的地方1)使用sync的时候，子组件传递的事件名必须为update:value，其中value必须与子组件中props中声明的名称完全一致(如上例中的myMessage，不能使用my-message2)注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model3)将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑 参考链接vue修饰符–可能是东半球最详细的文档（滑稽）]]></content>
      <categories>
        <category>vue 朝花夕拾系列</category>
        <category>vue 朝花夕拾系列（1）- vue内置指令和修饰符基础</category>
      </categories>
      <tags>
        <tag>vue 朝花夕拾系列（1）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F12%2F14%2Fregex%2F</url>
    <content type="text"><![CDATA[1.正则表达式是什么？​ 它是使用单个字符串来描述、匹配一系列某个语法规则的字符串。它经常可以被用来检索、替换那些某个匹配模式的文本。通俗的说就是按照某种规则去匹配符合条件的字符串。 举个栗子 ​ 2018-12-11 08:59:00 江伟哥发现我师傅还没有到公司，昨天说好的让我师傅早到给帮忙打个卡但都59分了自己都还没到。可更大的问题来了，江伟哥不知道我师傅把他的卡放在哪了。08:59:15，江伟哥慌忙之中拨通了第一个电话但却是空号，定睛一看号码1885646465，原来是慌乱中少输了一位号码。08:59:30，江伟哥拨通了第二个电话，电话那头传来一个女声：“你好，这里是和利时。”诧异之中江伟哥再次确认了一遍号码，029-96544856，原来刚才一个不小心通讯录里点到了和利时前台的电话，江伟哥气的拍起了大腿。08:59:50，再次拨通前，江伟哥一位一位的确认了号码，18856464655，没错了，赶紧拨通！随着电话那头我师傅带着倦意的一句“喂，哪位”，卡机上的时间跳到了09:00:00。2018-12-12，收到迟到罚款通知的江伟哥开始自闭。 匹配这段文字中符合规范的手机号：1[34578]\d{9} 匹配这段文字中所有的日期：\d{4}[/-]\d{2}[/-]\d{2} 对这段文字中匹配到的所有日期进行年月日的分组：(\d{4})[/-](\d{2})[/-](\d{2}) 2.正则表达式中的一些语法2.1.修饰符（g i m）​ 修饰符比较特殊，它放在表达式的最后，在构造函数声明的时候作为第二的参数被传进去的。整个表达式可以理解为匹配规则字符串+修饰符，修饰符有三个g、i、m，他们可以一起用。 g（global）：执行全局匹配 i（ignore case）：执行一个不区分大小写的匹配 m（multiple lines）：执行多行匹配 注：此处仅介绍了常用的三个，修饰符还包含s、U、X、A、D、e 2.1.1.全局匹配还是上面那段文字，如果在匹配日期的时候我使用全局匹配和不使用全局匹配的结果区别： 2.1.2.不区分大小写匹配​ 正如名字，就是在匹配的时候是否大小写敏感： 2.1.3.多行匹配​ 当使用多行匹配的时候，那么边界匹配符^和$将匹配行的开始和结束，反之则匹配整个字符串的开始和结束。如果将上面那段文字分为两段，每段使用一个&lt;p&gt;标签，那么我们尝试在多行模式开启以及不开启的时候匹配段落标签中的内容： 2.2.正则表达式字符的组成​ 正则表达式中由几种基本字符组成： 原义字符 非打印字符 元字符 2.3.原义字符​ 拿多行匹配的那个栗子来说，正则表达式中&lt;p&gt;就是原义字符，这个字符代表的就是它本身的意思。那么如果需要标记一个字符为特殊字符、或一个原义字符，那么就可以使用\符号将下一个字符标记转义。比如n将匹配一个字符n，而\n将匹配一个换行符。再比如^将作为起始边界的匹配标记，而\^将匹配^字符。 2.4.非打印字符​ 比如回车符、换行符、换页符等都属于非打印字符，它经常被用在文本文件的处理上： 字符 描述 \v 匹配一个垂直制表符，等价于 \x0b 和 \cK \f 匹配一个换页符，等价于 \x0c 和 \cL \n 匹配一个换行符，等价于 \x0a 和 \cJ \r 匹配一个回车符，等价于 \x0d 和 \cM \s 匹配任何空白字符，包括空格、制表符、换页符等等，等价于 [ \f\n\r\t\v] \S 匹配任何非空白字符，等价于 [^ \f\n\r\t\v] \t 匹配一个制表符，等价于 \x09 和 \cI 2.5.元字符2.5.1.字符类（ [ ] ）​ 比如在第一节我们匹配手机号所用的正则表达式中1[34578]\d{9}手机号的第二位可能是3、4、5、7、8中的任意一位，那[34578]就表示这些字符的一个集合。 2.5.2.字符类取反（ [ ^ ] ）​ 就是字符类的一个相反情况，表示不包含这些字符。 2.5.3.范围类（ [-] ）​ 正则表达式支持一定的范围规则，比如[a-z]表示字母a到z，[0-9]表示数字0到9。多种范围类可以写到一个字符类中，比如匹配字母a到z和数字0到9，那么就可以写成[a-z0-9]。 2.5.4.预定义类​ 有了这些预定义类，会简化正则表达式能够比较方便的书写。比如第一节举的栗子中匹配日期所使用的正则表达式\d{4}[/-]\d{2}[/-]\d{2}，\d就表示了数字字符，如果不适用预定义类，那么这个正则表达式会变得比较复杂[0-9]{4}[/-][0-9]{2}[/-][0-9]{2}： 字符 等价于 含义 . [^\n\r] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\n\x0B\f\r] 空白符 \S [^\t\n\x0B\f\r] 非空白符 \w [a-zA-Z_0-9] 单词字符（数字字母下划线） \W [^a-zA-Z_0-9] 非单词字符 2.5.5.边界​ 正如它的字面意思，边界就是定义匹配的边界条件。比如在2.1.3节中匹配&lt;p&gt;标签中段落所使用的^(&lt;p&gt;)就代表以&lt;p&gt;原义字符作为字符串的开始，(&lt;/p&gt;)$就代表以&lt;/p&gt;原义字符作为字符串的结尾。边界字符一共有四种： 字符 含义 ^ 以xxx开头 $ 以xxx结尾 \b 单词边界，指[a-zA-Z_0-9]之外的字符 \B 非单词边界 ​ \b和\B可能会稍微难理解一些，因为之前的元字符是匹配一个字符，而它俩匹配的是一个位置，这个位置就是单词边界位置（它的前一个字符和后一个字符不全是(一个是,一个不是或不存在) 单词字符），括号内的内容可以先不理解，继续向下看。 ​ 首先单词边界简单的来说就是单词（\w）和符号(\W)之间的位置，举一个栗子来更具体的说明：在@Hello,hollysys!这个字符串中单词边界的位置添加一个*号，那么结果就是@*Hello*,*hollysys*!。观察一下特征，我们再来理解上一段中下划线内容。单词边界前后相邻的两边一定一边是单词字符而另一边是非单词字符或者没有字符，如果符合这个规则，那么这个位置就是单词边界。\b匹配的就是这个位置，那么正则表达式\bHello就可以理解为：匹配处于单词边界位置的Hello，\B与之相反。 2.5.6.量词/重复/限定符​ 在2.5.4节中我们知道，匹配一个数字字符可以不使用范围类[0-9]而使用一个元字符\d。那如果匹配一个10位的数字需要\d\d\d\d\d\d\d\d\d\d吗？当然不用，量词简化了这种情况的书写方式： 字符 含义 ? 出现零次或一次 * 出现零次或多次(任意次) + 出现一次或多次（至少一次） {n} 对应零次或者n次 {n,m} 至少出现n次但不超过m次 {n,} 至少出现 ​ 在第一节栗子中匹配手机号所用的表达式1[34578]\d{9}最后的{9}就是一个量词，代表匹配9个数字字符。 2.5.7.贪婪与懒惰（ ? ）​ 贪婪和懒惰是描述正则表达式的两种匹配方式，正如其名贪婪就是匹配尽可能多的结果，懒惰则与之相反。默认情况下正则表达式会采用贪婪模式进行匹配，而在量词后加?则会使用懒惰匹配。在量词描述下匹配单词字符时，贪婪模式会采取上限去匹配，而懒惰模式会采取下限模式匹配。这里我们结合上一小节量词的内容举例说明：使用正则表达式\w{3,6}对字符串Hollysys进行贪婪和懒惰匹配，观察结果。 2.5.8.分支条件（ | ）​ 正则表达式中的分支条件就是几种规则，在表达式中使用|将不同的规则分开，在匹配时会对每个分支进行匹配，举个栗子： ​ 我们还是那开头那个栗子，我现在需要匹配全文中所有的江伟和师傅，那正则表达式就可以写成 江伟|师傅，提供了两种规则就可以将所有的结果匹配出来。 2.5.9.分组与反向引用 字符 含义 分类 (exp) 匹配exp，并将结果自动命名分组 捕获 (?\exp) 匹配exp，并将结果按指定名称命名分组 捕获 (?:exp) 匹配exp，但是不捕获结果也不对结果进行分组 捕获 (?=exp) 匹配exp前面的位置 断言 (?&lt;=exp) 匹配exp后面的位置 断言 (?!exp) 匹配后面不是exp的位置 断言 (?&lt;!exp) 匹配前面不是exp的位置 断言 (?#comment) 注释，不参与正则运算 注释 分组 ​ 分组又称为子表达式，干嘛用的？我又要举栗子了，首先我们看一种情况：如果我们需要将一个字符串中所有多个连续的abc替换为*号，那么我们结合2.5.6中所说的量词使用正则abc{2,}进行匹配，发现结果并不是所预期的，量词只作用到了c上而不是abc上。 ​ 这里为了使量词作用到abc上，就用到了分组的概念。正如本节开头所述，分组称为子表达式，abc就是一个只含有原义字符的表达式，使用圆括号将表达式括起来作为子表达式将子表达式匹配的结果做进一步处理，此时后面的量词就会作用在这个子表达式上。 反向引用 ​ 反向引用往往和分组一起使用，当一个表达式被分组之后，该表达式所匹配到的内容会被自动赋予一个组号。默认情况下从左到右以分组的左括号作为标志，按先后出现顺序编号1、2、3···(0对应整个正则表达式)通过组号可以获得对应表达式所匹配到的结果。如本文开头举栗中对匹配到的所有日期进行年月日的分组使用的正则表达式(\d{4})[/-](\d{2})[/-](\d{2})，我们来看下匹配的结果： ​ 当然除了默认的组号，还可以自己定义每一组的名称，我们对这个例子进一步改造，只需要在分组的子表达式前面添加?&lt;name&gt;使其这个分组有一个固定的名称。 注意：实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名的组分配，第二遍只给命名的组分配，因此所有命名组的组号都大于未命名的组号。 ​ 这里我们再提出一个场景，需要使用正则表达式匹配并取到下面域名列表中所有域名的名称： https://www.baidu.comhttp://www.hollysys.comhttps://www.qq.commysql://www.aliyun.com:3306/device_dbhttp://www.forkbteam.comhttps://163.comhttp://google.cntcp://127.0.0.1 ​ 那么我们可以使用正则表达式(?:http|https)://w*\.?(.*)\.(?:com|cn)进行匹配，当在子表达式最前面添加?:则不会捕获该组的结果，匹配结果如下图所示： 注：2.5节中省略了平衡组、零宽断言和负零宽断言的介绍。 3.正则表达式是如何匹配的？​ 那么正则表达式是怎么匹配的？它的工作机制是什么？这也是需要有些了解的，因为这对于写一个好的正则表达式非常有帮助，能有效提高匹配文本所需消耗的性能与时间。 3.1.正则表达式的工作机制3.1.1.匹配引擎眼里的字符串​ 在说到边界时，我们知道边界匹配的是一个位置，而预定义类等匹配的是一个字符。所以被匹配的一串字符Hollysys在正则匹配引擎眼里是含有位置占位符的0H1o2l3l4s5y6s7。 3.1.2.匹配流程 ​ 正则表达式在编译之后会从头字符开始匹配，如果匹配成功，会查找是否还有其他的路径没有匹配到，如果有的话，会回退到上一次成功匹配的位置然后重复第二步操作，不过此时开始匹配的位置是上次成功位置加1。这整个匹配过程的基础环节就是回溯，回溯是驱动正则匹配的一个基本动力，也是影响匹配性能的一个关键。 3.1.3.占有字符和零宽度​ 如果一个子表达式在匹配过程中匹配到了结果，而且这个结果不是一个位置而是一个字符，那么它所匹配到的结果会被它占有并保存到匹配结果中，这种称为占有字符。而如果匹配到的是一个位置，那么这个位置是不会被它占有更不会保存到匹配结果中去，这种称为零宽度。 ​ 占有字符是互斥的，零宽度是非互斥的，也就是说一个字符同一时间只能被一个表达式匹配，而一个位置在同一时间可以被多个零宽度表达式匹配。对，我要举栗子了： ​ 第一张图可以看到两个子表达式都在匹配同一个位置，结果中可以看到这个表达式执行成功。第二张图两个子表达式都在匹配字符f，但是无法匹配成功。因为当第一个子表达式将f占有后，第二个子表达式无法再找到符合条件的匹配而使得整个表达式匹配失败。 3.1.4.控制权和传动​ 正则表达式在由左向右依次匹配时，会有一个表达式先取得控制权，从某个位置开始匹配。当这个子表达式匹配结束后，会将控制权传动给下一个子表达式。下一个子表达式会从上一个表达式匹配成功之后的位置开始匹配，但如果上一个子表达式是零宽度，那么匹配的位置还是上一个子表达式匹配的位置。 3.2.运算优先级​ 正则表达式从左到右进行计算，并遵循优先级顺序。相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从由高到最低对元字符的优先级进行了排序： 元字符 描述 \ 转义符 ()，(?:)，(?=),[] 圆括号和方括号 *，+，?，{n}，{n,}，{n,m} 量词 ^，$，\任何元字符、任何字符 位置和顺序 \ 或 3.3.回溯​ 正则表达式中分支和量词出现的次数是比较多的，量词就如2.5.6小节所述，正则表达式需要决定何时去尝试匹配更多的字符。而分支如2.5.8小节最后的栗子一样，在匹配时我需要http和https两种情况开头的URL，那么（http|https）就提供了两个分支供正则选择。对于这种模糊条件匹配，最好的办法就是穷举，将所有可能的结果匹配一遍，一旦匹配成功立即返回结果。那么这里我们就这两种情况结合回溯分析正则表达式是如何匹配的。 3.3.1.分支&amp;回溯​ 在2.5.8小节中说到了分支，分支是提供多个规则给正则表达式进行匹配，为了去匹配这些规则就需要进行回溯。这里通过描述正则表达式H(ollysys|ere)&lt;/p&gt;对Here is &lt;p&gt;Hollysys&lt;/p&gt; company的匹配过程来展示分支的回溯过程。 匹配结果 说明 H 在位置0匹配到了字符H H 选择ollsys分支进行匹配 He 位置1不是字符o，回溯 H 选择ere分支进行匹配 He 位置1上成功匹配字符e Here 位置2、3上成功匹配字符re，该分支匹配成功 Here 位置4不是字符&lt;，该路径匹配失败 Null 位置2不是字符H，匹配失败 ··· ··· H 位置11匹配到字符H H 选择ollsys分支进行匹配 Hollysys 匹配到了ollysys，该分支匹配成功 Hollysys&lt; 在位置9匹配到了字符&lt; Hollysys\ 在位置10、11、12上匹配到了/p&gt; Hollysys\ 该路径匹配成功 注：正则表达式是从左到右依次匹配，如果满足了某个分支的话它就不会再管其他分支了 3.3.1.量词&amp;回溯​ 如2.5.7小节所述，在使用量词匹配时有贪婪和懒惰两种匹配模式，该小节中我们使用正则表达式&lt;.*&gt;和&lt;.*?&gt;对字符串Here is &lt;p&gt;Hollysys&lt;/p&gt; company进行匹配。那么是如何匹配的呢？ `&lt;.*&gt; 匹配结果 说明 &lt; 先匹配&lt;字符，在位置8匹配成功 \Hollysys\ company 默认贪婪匹配，量词取上限.*一下吞噬后面的所有字符 \Hollysys\ company 后面没有字符供&gt;匹配，回溯，要求.*吐一个字符出来 \Hollysys\ compan 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ compa 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ comp 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ com 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ co 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ c 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ 吐得字符不是&gt;，回溯，再给我吐一个 \Hollysys\ 是&gt;，完成匹配 &lt;.*?&gt; 匹配结果 说明 &lt; 先匹配&lt;字符，在位置8匹配成功 \&lt; 懒惰匹配，量词取下限0，.*被忽略 \&lt;p 不是&gt;，回溯 \&lt;p .*匹配1个字符 \ 是&gt;，完成匹配 \、\ 全局匹配，未到尾部继续按上述步骤向前匹配又找到&lt;/p&gt; 3.4.分组​ 在2.5.9中我们说到了分组捕获以及对组的命名，那么我们来看一种情况： ​ 当对两个组使用相同的名称时，最终的结果只会显示最后一个，是被覆盖了么？其实每一个组都是一个堆栈，当正则从左向右匹配分组内的子表达式时，会将匹配结果捕获出来压入指定名称的栈中。而组获取的文本是栈顶的数据，所以最终取到的结果是sys。但我只想要上一个结果怎么办？那就可以使用(?&#39;-one&#39;)将顶部的栈弹出： 3.5.正则表达式优化的一些小技巧 避免重新编译，编译正则表达式的次数尽可能的少； 如果不需要括号内的子表达式匹配结果，最好使用非捕获符号?:； 不要滥用括号和字符组； 从量词中提取出来必须的元素； 提取分支条件开头或结尾必须的元素； 使用正确的边界符限定搜索区域； 尽量不适用通配符，使用具体的元字符； 使用正确的量词，并尽可能限定长度； 4.一些正则调试辅助工具4.1.Regexper​ Regexper是一款JavaScript可视化正则调试工具，它可以解析正则表达式并将匹配方式可视的显示出来，这比直接读正则表达式方便了很多，也编译找出自己写的表达式中存在哪些逻辑或者语法上的错误。 工具地址：Regexper 4.2.在线正则表达式测试​ 这个是比较简单的轻量级在线调试工具，并提供了一些常用的表达式。 工具地址：在线正则表达测试 4.3.正则表达式测试器​ 也是一个轻量级桌面版正则表达式测试工具，展示比上面那个在线版要友好很多，支持匹配数据的导出。 下载地址：正则表达测试器 4.4.RegexBuddy​ 这个工具是一款功能强大的正则表达式编辑工具，使用能够帮助用户快速自动生成正则表达式，支持自动检查和修改生成的正则表达式，可在样本字符串和文件上快速测试任何正则表达式，防止实际数据出错。通过逐步完成实际的匹配过程来进行无猜测调试。最主要的，它可以对正则表达式进行Debug，他会以树状列表显示正则匹配的每一个过程和匹配最终的步长，这对性能优化有着非常大的帮助。]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript - 常见的五种this指向]]></title>
    <url>%2F2018%2F11%2F21%2Fthis%2F</url>
    <content type="text"><![CDATA[Javacript中this的使用this 在js中是一个关键字，它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。简单的来说，this就是函数运行时所在的环境对象。今天我们来看一下常见的this的四种使用… 函数调用 严格模式下不允许this指向全局变量 非严格模式下this就是指向全局变量 12345678// 严格模式下‘use strict’function thisFun()&#123; console.log(this)&#125;thisFun() // undefined// 非严格模式下thisFun(); // window 对象的方法调用 调用对象的方法，this指向方法的调用者 将对象的方法赋值给另一个变量，this指向该变量所在的对象上。 1234567891011121314151617var userName = 'cindy'var userInfo = &#123; userName:'pis', getUserName:function()&#123; console.log(this.userName) &#125;&#125;userInfo.getUserName(); // pisvar otherUser = userInfo.getUserName;otherUser();// window cindyvar me = &#123; userName:'eric', realName:''&#125;me.realName = userInfo.getUserName;me.realName() // me eric 构造函数在js中，为了实现类，定义了构造函数，在调用构造函数生成实例的时候，使用new操作符 12345var name = 123;function Animal()&#123; this.name = 'cat';&#125;var mimi= new Animal(); // this指向构造函数生成的实例对象 call apply bind apply、call、bind的作用 在javascript中，三者作用是改变某个函数的执行上下文（Execution Context），具体作用是改变函数体内部this的指向。 举个栗子： 1234567891011121314151617 function example() &#123;&#125; example.prototype = &#123; name: 'will', say: function() &#123; console.log('hi,' + this.name + '!') &#125;&#125; var e = new example() e.say() // hi,will! var obj = &#123; name: 'lucky' &#125; e.say.apply(obj) // hi,lucky! 此时this.name是lucky e.say.call(obj) // hi,lucky! 此时this.name是lucky e.say.bind(obj)() // hi,lucky! 此时this.name是lucky apply、call、bind的区别 apply、call只是接受参数的方式不太一样，而且会立即执行，bind会产生一个新函数，需要再次调用才会执行 举个栗子： 12345function func(arg1, arg2) &#123; console.log(arg1 + arg2)&#125;func.apply(this, [1, 2]) // apply接受的参数，第一个是对象，第二个是数组func.call(this, 1, 2) // call接受的参数，第一个是对象，后面一个接一个 简单举几个apply、call、bind的应用场景 伪数组转标准数组 1234567var obj = &#123; 0: 1, 1: 2, length: 2&#125;var arr1 = Array.prototype.slice.call(obj) // [1, 2]var arr2 = Array.prototype.slice.apply(obj) // [1, 2] 取数组中的最大值或者最小值 123456789var arr = [1, 2, 3, 4]//取最大值console.log(Math.max.apply(Math, arr)) // 4console.log(Math.max.call(Math, ...arr)) // 4//取最小值console.log(Math.min.apply(Math, arr)) // 1console.log(Math.min.call(Math, ...arr)) // 1 检验是否是数组 12345function isArray(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]'&#125;isArray([1]) // trueisArray(&#123;&#125;) // false React中使用bind使函数可以获取到props 12345678910 class MyCircle extends Component &#123; constructor(props) &#123; super(props) this.func = this.func.bind(this) &#125; func() &#123; ... &#125; ...&#125; 等等… 总结 三者作用都是改变函数this的指向三者第一个传参都是要this要指向的对象apply、call是立即执行函数，bind需要再次调用]]></content>
      <categories>
        <category>javascript</category>
        <category>javascript - 常见的五种this指向</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[currentFrontEnd]]></title>
    <url>%2F2018%2F11%2F19%2FcurrentFrontEnd%2F</url>
    <content type="text"><![CDATA[Front-end evolution简单介绍一下我理解的前端技术演进… 第一阶段：刀耕火种基本的事件响应机制 获取view上的dom 对dom进行事件绑定 根据事件响应改变视图 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;label&gt;用户输入&lt;label for="userInput"&gt;&lt;/label&gt;&lt;input type="text" id="userInput"&gt; &lt;button id="submitButton"&gt;提交&lt;/button&gt; &lt;p id="userComment"&gt;&lt;/p&gt; &lt;/body&gt; &lt;script&gt; // 页面dom加载完毕 window.onload = function () &#123; var userInput = bindDom('userInput'); var submitButton = bindDom('submitButton'); var userComment = bindDom('userComment'); submitButton.addEventListener('click',function()&#123; userComment.innerHTML = userInput.value; &#125;); &#125;; // bind dom function bindDom(domID)&#123; return document.getElementById(domID) &#125; &lt;/script&gt;&lt;/html&gt; demo1 频繁的操作dom，性能差，视图view和业务逻辑的js文件揉在一起，维护性差，可读性差，无法复用 第二阶段：前端模块化 什么问题导致我们需要前端页面进行组件化？ 组件化究竟时要解决什么问题？答：为了解决结构服用，避免产生重复冗余的代码 模块化第一阶段：原始的组建化写法(在全局对象上定义模块的属性和方法)模块就是实现特定功能的一组方法－所以把不同的函数和变量简单的放在一起就算是一个模块 123456789var name = 'pis';var age = 18;function getName()&#123; return this.name&#125;function getAge()&#123; return this.age&#125; getName getAge方法组成了一个模块，使用的时候直接调用就可以了。 缺点: 污染了全局变量不能保证在引入其他模块的时候不会发生变量名冲突和方法被overwrite模块成员之间看不出直接关系 模块化第二阶段：对象的写法为了解决上面的问题，可以把模块的方法放到一个对象里面，这样就解决了上面的问题 12345678910var module = &#123; name:'unclepis', age:18, getName:function()&#123; return this.name &#125;, getAge:function()&#123; return this.age &#125;&#125; 这样所有的模块方法都封装在了对象里面，使用的时候就是调用这个对象的方法就可以了 module.getName() // unclepis 缺点： 暴漏了所有的模块成员内部的状态可以被外部改写 module.name = ‘eric’ 模块化第三阶段：自执行函数123456789101112131415var module = (function()&#123; var name = 'cindy'; var age = 18; var getName = function()&#123; return name; &#125; var getAge = function()&#123; return age; &#125; return&#123; getName:getName, getAge:getAge &#125;&#125;)(); 这样的写法使得外部不能获取内部变量，又对外暴漏了模块的接口，所以这就是在es6模块化之前比较主流的模块化写法 自执行函数模块化扩展1：放大模式＋自执行函数如果一个模块很大或者一个模块需要依赖另一个模块，这时候就需要使用放大模式 1234567var getMoreInfo = (function(mod)&#123; mod.getJobInfo = function()&#123; // 引入前面封装好的module，已经有了getName和getAge的方法，又引入了新的方法getjobinfo &#125; return mod;// 返回新的模块&#125;)(module); 自执行函数模块化扩展2：由于浏览器环境中，模块的各个部分通常都是从网上获取的。无法控制资源的加载顺序(requirejs这种amd的方式先不考虑)，所以上面引入的module可能在执行的时候还是一个空对象 1234567var getMoreInfo = (function(mod)&#123; mod.getJobInfo = function()&#123; // 引入前面封装好的module，已经有了getName和getAge的方法，又引入了新的方法getjobinfo &#125; return mod;// 返回新的模块&#125;)(module||&#123;&#125;); // 所以需要给模块设置默认的空对象 第三阶段：模块化规范通过上面的介绍，我们大概知道了，如何使用自执行函数来封装一组方法集合的模块，这样在模块中对外暴漏了接口方法，但是又不污染全局变量，而且不能在外部随意更改模块的内部变量。虽然这样我们有了模块，可以很方便的服用别人的代码，想要什么功能就加载什么功能，但是每个人的写法可能不一样，所以模块化的规范在社区中慢慢衍生出来… 目前主流的js模块化规范主要包括三个: CMD(common module defination)通用模块化定义 AMD(Asynchronous module defination) 异步模块化定义 CMD 09年nodejs项目使得js可以运行在服务器端。这也就标志着js模块化变成正式诞生 浏览器环境下网页的复杂性有限，没有模块化问题不是很大，但是运行在服务器端，与操作系统和其他应用程序相互互动，模块化势在必行，否则没发编程 nodejs的模块系统就是参考commonjs规范实现的，在commonjs中有一个全局性的方法require用于加载模块 12var jquery = require(&apos;./jquery.js&apos;);jquery.Ajax(); //这样就可以调用了 在服务器端运行的时候，所有的模块都存放在服务器本地的磁盘上，等待的事件也就是硬盘读取的时间但是如果运行在浏览器上的化，网络的加载可能会使得模块的加载出现⌛️，也就是出现我们常说的页面假死…因此浏览器端不能使用commonjs这种同步加载的方法，只能采用异步加载的方式，这也就诞生了AMD规范… AMDAMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 1234//AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：require(['math',function(math)&#123; math.add(2,3);&#125;]) math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。 为什么引入amd?最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。 123456&lt;script src="1.js"&gt;&lt;/script&gt; &lt;script src="2.js"&gt;&lt;/script&gt; &lt;script src="3.js"&gt;&lt;/script&gt; &lt;script src="4.js"&gt;&lt;/script&gt; &lt;script src="5.js"&gt;&lt;/script&gt; &lt;script src="6.js"&gt;&lt;/script&gt; 这段代码依次加载多个js文件。 这样的写法有很大的缺点。 首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长； 其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 所以amd的规范就是为了解决这个问题：（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 第四阶段：前端mvc架构构架模式如何设计一个程序的结构，就是一个架构模式，属于编程的方法论…(演示需要将demo用http-server跑起来) mvc构架模式MVC就是一种常用的软件构架模式，这个模式任务，任何程序，无论简单与否，从结构上都分为三层：分别代表: Modal模型 (数据存储) view视图 (用户界面) controller控制 (业务逻辑) step1: View 传送指令到 Controllerstep2: Controller 完成业务逻辑后，要求 Model 改变状态step3: Model 将新的数据发送到 View，用户得到反馈 基本的MVC构架模式，所有通信都是单项的 实际的业务构架基本上就可以覆盖我们常见的大多数场景 视图层上的用户交互，通过控制器，对数据模型进行操作，然后数据模型的变化也会动态的更新到视图上… mvp/mvvm构架模式(model view Presenter)/(model view viewModel)在MVC的基础上，进而演进出了视图view和数据模型model的双向绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;label&gt;用户输入&lt;label for="userInput"&gt;&lt;/label&gt;&lt;input type="text" id="userInput"&gt; &lt;p id="userComment"&gt;&lt;/p&gt;&lt;/body&gt;&lt;script&gt; // 页面dom加载完毕 window.onload = function () &#123; // view视图上dom元素 var userInput = bindDom('userInput'); var userComment = bindDom('userComment'); // model数据 window.data = &#123; userInput: 'uncle pis' &#125;; userInput.value = data.userInput; // 使用model的数据初始化视图的显示 userComment.innerHTML = data.userInput; // 使用model的数据初始化视图的显示 // 数据双向绑定是通过Object.definePropery的get和set对数据进行劫持，监听数据的变化 Object.defineProperty(window.data,'userInput', &#123; set: function (val) &#123; userComment.innerText = val; userInput.value = val; &#125;, get: function () &#123; console.log('get User input '); &#125; &#125;) userInput.addEventListener('keyup', function (e) &#123; data.userInput = e.target.value; &#125;); &#125;; // bind dom function bindDom(domID) &#123; return document.getElementById(domID) &#125;&lt;/script&gt;&lt;/html&gt; demo2 观察者模式和发布订阅模式的有什么区别？在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们 简单的说就好比找工作：目标公司(Subject)找工作的人 (Observers)职位空缺(消息事件)所以 当职位空缺的时候，目标公司就会通知找工作的人 发布订阅在发布-订阅模式，消息的发送方，叫做发布者（publishers），消息不会直接发送给特定的接收者（订阅者）。发布者和订阅者不知道对方的存在。需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息 简单的说就好比买卖房子房主(publisher)就是发布者房产中介(信息中介)买房子的人(订阅者) 房主和买房子的人不知道对方的存在，消息通过中介进行传输 区别在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 数据劫持和观察者模式上面的例子，我们通过object.definePropery方法，通过get和set方法对data数据进行了劫持；然后在数据发生变化的时候，通知给视图上的观察者，来完成视图和数据的关联。 第五阶段：前后端分离＋Ajax+restful标量－序列－映射从yaml文档中说，从结构上看，所有的数据data最终都可以分解成三种类型1）第一种是标量（scalar），也就是一个单独的字符串string或者数组numbers2）第二种是序列（sequence），也就是若干个有序的数据并列在一起，又叫做数组array或是列表list3）第三种是映射（mapping），也就是一个健值对（key/value）,即数据又一个名字，还有一个对应的值，着又称作散列（hash）或是字典（dictionary） JSON而21世纪初期，就是一个叫做json的数据格式代替了xml在服务器间进行数据交换传输。什么格式的数据是json？ 并列数据的集合（数组）用方括号([])表示 并列的数据之间用逗号（“，”）分开 映射用冒号（“：”）表示 映射的集合（对象）用话括号（｛｝）表示 上面四条规则，就是Json格式的所有内容。例如：宁波和利时应用开发部有20人，java开发15人，前端开发4人，测试1人就可以用json表示成 123456789101112131415&#123; company:'宁波和利时'， total_people:20, department:'应用开发部门'， role:[&#123; number:15, name:'java' &#125;,&#123; number:4, name:'js' &#125;,&#123; number:1, name:'测试' &#125;]&#125; 注：js中数组和对象的区别学习javascript的时候，我曾经一度搞不清楚”数组”(array)和”对象”(object)的根本区别在哪里，两者都可以用来表示数据的集合。 比如有一个数组a=[1,2,3,4]，还有一个对象a={0:1,1:2,2:3,3:4}，然后你运行alert(a[1])，两种情况下的运行结果是相同的！这就是说，数据集合既可以用数组表示，也可以用对象表示，那么我到底该用哪一种呢？ 我后来才知道，数组表示有序数据的集合，而对象表示无序数据的集合。如果数据的顺序很重要，就用数组，否则就用对象。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>mvc</tag>
        <tag>mvvm</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2018%2F11%2F01%2Fcanvas%2F</url>
    <content type="text"><![CDATA[背景最近项目上通过iframe嵌入了一个公司其他组开发的工业组态，所以之前的几个文章都是在解决iframe跨域通信的问题.因为项目部署在阿里云上，域名类似于xxx.com，而iframe嵌套的组态是一个子域名页面，类似a.xxx.com。 单点登录因为是别的组开发的组态，所以实际上在开发中也是需要登陆的，通过将子域名的domain使用了domain.cookie=”xxx.com”设置成主域名的方式共享了cookie中在登录时存储的token，使得用户登录后访问组态不用再次登陆. iframe通信因为iframe里面实际上时用canvas画的工业组态，然后在iframe外面有一些按钮，需要放大缩小组态，这就牵扯到iframe和外面的通信，通过h5的postMessage，使用事件的方式完成了通信。 主要的问题解决了，剩下的就是通过组态页面的点击，在页面上获取数据，使用canvas画图，一直没有使用canvas的场景，常用的数据可视化都是使用echart等库完成了，最近刚好业务上使用，打算花点时间看看canvas canvas &lt;canvas&gt; 是 HTML5 新增的，一个可以使用脚本(通常为JavaScript)在其中绘制图像的 HTML 元素。 width和height12&lt;!-- &lt;canvas&gt; 只有两个可选的属性 width、heigth 属性.默认width 300px height 150px --&gt;&lt;canvas id="canvasApp" widht="300" height="300"&gt;试一下浏览器支持不&lt;/canvas&gt; 浏览器不支持的替换消息 ​ 支持 &lt;canvas&gt; 的浏览器会只渲染 &lt;canvas&gt; 标签，而忽略其中的替代内容。不支持 &lt;canvas&gt; 的浏览器则 会直接渲染替代内容。 示例123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;title&gt;Canvas tutorial&lt;/title&gt; &lt;style type="text/css"&gt; canvas &#123; border: 1px solid black; &#125; &lt;/style&gt; &lt;/head&gt; &lt;canvas id="tutorial" width="300" height="300"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; function draw()&#123; // 1.获取canvas的doom var canvas = document.getElementById('cavansApp'); // 2. 获取渲染上下文 if(!canvas.getContext) return; var ctx = canvas.getContext("2d"); //开始代码 &#125; draw(); &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript - 事件循环(Event loog)]]></title>
    <url>%2F2018%2F10%2F31%2FevenLoop%2F</url>
    <content type="text"><![CDATA[事件循环javascript语言的特点就是单线程，也就是在同一时间只能做一件事情，其他线程在事件队列里面等待主线程空闲，然后事件队列按照队列的顺序一次在主线程执行… 单线程 因为js是客户端脚本，由于js主要的用途是处理用户的交互，所以如果是多线程，当用户又多个操作的时候，不好进行管理。 单线程就意味着，所有的任务都需要排队，前一个任务执行结束，才会执行下一个任务。 同步任务和异步任务 同步任务: 在主线程上执行的任务，只有当上一个任务执行完毕，下一个任务才会执行，所以如果一个任务耗时很长，下一个任务就会等待，形成阻塞 异步任务：不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才进入主线程执行 一般来说，有以下四种会放入异步任务队列：： setTimeout和setlnterval Ajax异步请求 promise dom事件 js的执行机制（主线程 + event task事件队列+ event loop事件循环）上面你说了同步任务和异步任务，事件循环其实就是检测任务执行的一个过程1.所有的同步任务在主线程上执行，形成一个执行栈2.在主线程之外，还有一个任务队列，只有当异步任务又了结果，都会在任务队列中放置一个事件3.一旦执行栈道中所有的同步任务执行完毕，也就是说主线程空闲，系统就会读取执行队列的事件，也就是执行将异步任务的结果放入执行栈4.主线程不同重复上面的三个步骤]]></content>
      <categories>
        <category>javascript</category>
        <category>javascript - 事件循环(Event loog)</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
        <tag>event loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript - Dom常用操作(element)]]></title>
    <url>%2F2018%2F10%2F30%2Felement%2F</url>
    <content type="text"><![CDATA[HTML DOM Element 对象最近在看react状态驱动视图的具体实现，里面通过creatElement方法将dom字符串转换成dom元素，进而绑定事件；然后又使用insertBefore和removeChild方法通过state的变化重新调用render方法刷新视图；看到这顺便整理一下dom中对元素增删改查的基本方法，方便后面使用查看…. HTML DOM 节点 在 HTML DOM （文档对象模型）中，NodeList 对象表示节点列表，比如 HTML 元素的子节点集合。每个部分都是节点： 文档本身是文档节点 所有 HTML 元素是元素节点 所有 HTML 属性是属性节点 HTML 元素内的文本是文本节点 注释是注释节点 appendChild() 向元素添加新的子节点，作为最后一个子节点。12345let childDom = document.createElement('span');let childDomTextNode = document.createTextNode('hello world');childDom.appendChild(childDomTextNode);// &lt;span&gt;hello world&lt;/span&gt; removeChild() 方法指定元素的某个指定的子节点。12345let childDom = document.createElement('span');let childDomTextNode = document.createTextNode('hello world');childDom.removeChild(childDomTextNode);// &lt;span&gt;&lt;/span&gt; hello world被移除 insertBefore(newItem,existingItem) 方法在您指定的已有子节点之前插入新的子节点。1&lt;ul id="myList"&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt; 1234567let target = document.getElementById('myList');let childDom = document.createElement('span');let childDomTextNode = document.createTextNode('hello world');childDom.appendChild(childDomTextNode);target.insertBefore(childDom,target.childNodes[0]);// &lt;span&gt;&lt;/span&gt; hello world被移除]]></content>
      <categories>
        <category>javascript</category>
        <category>javascript - Dom常用操作(element)</category>
      </categories>
      <tags>
        <tag>createElement</tag>
        <tag>createTextNode</tag>
        <tag>insertBefore</tag>
        <tag>removeChild</tag>
        <tag>appendChild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react]]></title>
    <url>%2F2018%2F10%2F30%2Freact%2F</url>
    <content type="text"><![CDATA[react读书笔记现在基本上angularjs，react和vue都用过好几个项目了。根据项目，技术栈也在不断变化，长时间不写总有点生疏，最近回过头来看一下react的东西，记录一下，方便后面回过头来看… reactjs 一个根据数据驱动视图的UI库，相当于MVC中的view reactjs帮我们将视图切分成各个独立的小块，每个快就是一个组件，可以任意嵌套拼装成需要的视图 reactjs不是一个框架，她提供了视图层的解决方案，还要依赖类似于react-router和redux等库才能提供完整的解决方法 前端组件化 什么问题导致我们需要前端页面进行组件化? 组件化是为了解决什么问题? 答：为了解决结构复用，避免产生重复冗余的代码 例如1234567891011121314151617&lt;body&gt; &lt;div class='wrapper'&gt; &lt;button class='like-btn'&gt; &lt;span class='like-text'&gt;点赞&lt;/span&gt; &lt;span&gt;👍&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;script&gt; let likeButton = document.querySelector('.like-btn'); let likeButtonText = document.querySelector('.like-text'); let isLike = false; likeButton.addEventListener('click',function()&#123; isLike = !isLike; likeButtonText.innerText = isLike?'取消':'点赞'; &#125;),false; &lt;/script&gt; &lt;/body&gt; 这样就可以完成一个点击按钮切换按钮功能，可是这个功能要共享，只能将全部的代码全部粘贴过去，复用性何在? 组件复用-引入class假如定义一个构造函数 1234567891011class LikeButton&#123; render()&#123; return `&lt;div class='wrapper'&gt; &lt;button class='like-btn'&gt; &lt;span class='like-text'&gt;点赞&lt;/span&gt; &lt;span&gt;👍&lt;/span&gt; &lt;/button&gt; &lt;/div&gt;` &#125;&#125; 这样就可以使用new生成实例了。 12let buttonOne = new LikeButton()document.getElementById('root').innerHTML = buttonOne.render(); 问题又来了，点击没有作用，因为没有绑定事件。没法给字符串添加事件，只有dom结构才能绑定dom事件 123456789101112131415161718192021222324252627282930313233 // 使用createElement方法将字符串转换成dom对象 let string2Html = function(str)&#123; let divDom = document.createElement('div'); divDom.innerHTML = str; return divDom; &#125; class LikeButton&#123; constructor()&#123; this.state = &#123; isLike:false &#125; &#125; changeButtonText()&#123; const likeText = this.element.querySelector('.like-text'); this.state.isLike = !this.state.isLike; likeText.innerHTML = this.state.isLike?'取消':'点赞' &#125; render()&#123; this.element = string2Html(` &lt;div class='wrapper'&gt; &lt;button class='like-btn'&gt; &lt;span class='like-text'&gt;点赞&lt;/span&gt; &lt;span&gt;👍&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; `); this.element.addEventListener('click',this.changeButtonText.bind(this)) return this.element &#125; &#125; let button1 = new LikeButton()document.querySelector('.root').appendChild( button1.render()) // 将生成的dom实例放入root节点 问题又来了，再changeButtonText方法中，通过state的状态来修改按钮的文字，这样频繁操作dom，这样手动管理state的变化刷新dom视图react提供了一种解决办法: 状态改变-》更新状态-》用新的state重新调用render方法刷新视图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 使用createElement方法将字符串转换成dom对象let string2Html = function(str)&#123; let divDom = document.createElement('div'); divDom.innerHTML = str; return divDom;&#125;class LikeButton&#123; constructor()&#123; // 初始化一个状态 this.state = &#123; isLike:false &#125; &#125; // 状态变化更新状态，重新使用新的状态调用render生成视图 setState(state)&#123; const preElement = this.element; this.state = state; this.element = this.render(); if(this.onStateChange)&#123; // 判断一下实例有没有这个方法 // 通过这个方法的调用刷新视图 this.onStateChange(preElement,this.element); &#125; &#125; // 调用状态更新的方法 changeButtonText()&#123; this.setState(&#123; isLike:!this.state.isLike &#125;) &#125; render()&#123; this.element = string2Html(` &lt;div class='wrapper'&gt; &lt;button class='like-btn'&gt; &lt;span class='like-text'&gt;$&#123;this.state.isLike?"取消":"点赞"&#125;&lt;/span&gt; &lt;span&gt;👍&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; `); this.element.addEventListener('click',this.changeButtonText.bind(this)) return this.element &#125;&#125;// 调用这个构造函数生成这个一个简单功能的组件let button1 = new LikeButton()let container = document.querySelector('.root');container.appendChild( button1.render()) // 将生成的dom实例放入root节点button1.onStateChange= function(pre,curr)&#123; container.insertBefore(curr,pre) // 在上次渲染的元素前面插入元素 container.removeChild(pre) // 删除旧的dom&#125; 完成一个基本的组件化，那么又有一个细节，就是每次state状态变化的时候，都要操作dom刷新视图，这个在reactjs中通过virtual-dom的策略，可以将几次视图的刷新进行合并，提高性能。但是还有一个问题，就是如果要新建一个组件，那么中间的setState更新状态的方法是重复的，所以需要抽出一个公共的类 抽象出公共组件的类1234567891011121314151617class React.Component &#123; setState(state)&#123; const preElement = this.element; // 组件的dom this.state = state; // 根据传入的新的state更新组件的state this.element = this._renderDOM() // 重新调用render方法生成新的dom if(this.onStateChange)&#123; this.onStateChange(preElement,this.element) // 通知组件的实例更新页面的视图 &#125; &#125; _renderDOM()&#123; this.element = string2Html(this.render()) // 每个组件都有一个render方法 if(this.onClick)&#123; this.element.addEventListener('click',this.onClick.bind(this)); &#125; return this.element &#125;&#125; 这样所有的组件都可以集成这个父类 123456789101112131415161718192021import &#123;Component&#125; from 'React';class LikeButton extends Component&#123; constructor () &#123; super() this.state = &#123; isLiked: false &#125; &#125; onClick () &#123; this.setState(&#123; isLiked: !this.state.isLiked &#125;) &#125; render () &#123; return ` &lt;button class='like-btn'&gt; &lt;span class='like-text'&gt;$&#123;this.state.isLiked ? '取消' : '点赞'&#125;&lt;/span&gt; &lt;span&gt;👍&lt;/span&gt; &lt;/button&gt; ` &#125;&#125; 这样定义的组件LikeButton就可以在state状态变更的时候调用基类的setState方法重新render 参考链接 react.js]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器跨域系列（4）- 跨域和location.hash]]></title>
    <url>%2F2018%2F10%2F26%2FhashAndWindowName%2F</url>
    <content type="text"><![CDATA[除了前面说的jsonp，postMessage，domain的方式跨域，还有两种共享数据的方式… window.name跨域1234567景1：现在浏览器的一个标签页里打开http://www.damonare.cn/a.html页面，你通过location.href=http://baidu.com/b.html，在同一个浏览器标签页里打开了不同域名下的页面。这时候这两个页面你可以使用window.name来传递参数。因为window.name指的是浏览器窗口的名字，只要浏览器窗口相同，那么无论在哪个网页里访问值都是一样的。场景2：你的http://www.damonare.cn/a.html页面里使用&lt;iframe&gt;调用另一个http://baidu.com/b.html页面。这时候你想在a页面里获取b页面里的dom，然后进行操作。然后你会发现你不能获得b的dom。同样会因为不同源而报错，和上面提到的不同之处就是两个页面的一级域名也不相同。这时候document.domain就解决不了了。解决方案：浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。。比如你在b页面里设定window.name="hello"，你再返回到a页面，在a页面里访问window.name，可以得到hello。这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。 location.hash跨域12345ocation.hash就是指URL的#号后面的部分。场景：父窗口和iframe的子窗口之间通讯或者是window.open打开的子窗口之间的通讯。解决方案：父窗口改变子窗口的url的#号后面的部分，后者把要传递的参数写在#后面，子窗口监听window.onhashchange事件，得到通知，读取window.location.hash解析出有用的数据。同样子窗口也可以向父窗口传递数据。]]></content>
      <categories>
        <category>浏览器跨域系列</category>
        <category>浏览器跨域系列（4）- 跨域和location.hash</category>
      </categories>
      <tags>
        <tag>location.hash</tag>
        <tag>window.name</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器跨域系列（3）- 跨域和domain]]></title>
    <url>%2F2018%2F10%2F26%2Fdomain%2F</url>
    <content type="text"><![CDATA[document.domain前面已经介绍了怎么使用jsonp跨域获取数据，怎么使用h5的postMessage跨域在多窗口之间传递消息，经常遇见的业务需求还需要跨域共享cookie或者跨域获取dom元素，今天说一下document.domain的方式实现跨域… 只能用于主域名一样的场景（操作dom或者发送数据交互） 修改domain跨域操作dom 场景1：你的 http://xxx.cn/a.html页面里使用 &lt;iframe&gt; 调用另一个 http://www.xxx.cn/b.html 页面。这时候你想在a页面里获取b页面里的dom，然后进行操作。然后你会发现你不能获得b的dom。document.getElementById(“myIFrame”).contentWindow.document或window.parent.document.body因为两个窗口不同源而报错。 解决方案：这时候你只需要在a页面里和b页面里把document.domain设置成相同的值就可以在两个页面里操作Dom了。 需要注意的一点：使用document.domain要求必须主域一样，子域名可以不一样，但是有时候端口可能不一样，这个主域名和子域名都要设置一下document.domain，将端口号都重置成null，否则端口号不一样还是会报跨域错误 修改domain共享cookie 场景2：你在 http://xxx.cn/a.html 页面里写入了 document.cookie = &quot;test1=hello&quot;; 你在 http://www.xxx.cn/b.html 页面是拿不到这个cookie的。 解决方案：Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名。这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 注意：document.domain限制：虽然可读写，但只能设置成自身或者是高一级的父域且主域必须相同。所以只能解决一级域名相同二级域名不同的跨域问题。document.domain只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法跨域。 本地尝试由于xxxx.baidu.com和baidu.com这种主域和子域名不同不太好模拟，所以我想在本地模拟一下，使用http-server在不同的端口模拟一下使用document.domain跨域获取iframe的dom元素.. 在127.0.0.1:3001拉起的test2.html 1234567891011&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; iframe window &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p id='hello'&gt;123&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在127.0.0.1:3000拉起的 test.html 1234567891011&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;title&gt; main window &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src="http://127.0.0.1:3001/test2.html" name="myframe" width="500" height="100"&gt;你的浏览器不支持iframe&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 可以看见我在127.0.0.1:3000/test.html里面嵌入127.0.0.1:3001/test2.html文件，由于端口不一致，所以我在test.html里面是没法获取test2.html里面的元素的 使用document.domain修改成相同的域名 12345&lt;script type="text/javascript"&gt; window.onload=function()&#123; document.domain = '127.0.0.1'; &#125; &lt;/script&gt; 可以看见现在在test.html页面意境可以获取到test2.html页面的id为hello的元素了。也不报跨域错误了]]></content>
      <categories>
        <category>浏览器跨域系列</category>
        <category>浏览器跨域系列（3）- 跨域和domain</category>
      </categories>
      <tags>
        <tag>domain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器跨域系列（2）- 跨域和postMessage]]></title>
    <url>%2F2018%2F10%2F26%2FpostMessage%2F</url>
    <content type="text"><![CDATA[在跨域和jsonp的文章里面已经介绍了跨域的基本概念，也介绍了jsonp跨域的原理(script标签+服务器和客户端约定好callback)基本写法和jquer封装;本文介绍window.postMessage()的h5接口实现不同窗口不同页面的跨域通信; 可以发送数据 可以通过发送特定的事件名称，在onMessage里面执行回调，类似于angular的emit和on的关系然后操作dom postMessage()123456789101112someWindow.postMessage(data,origin); `&lt;iframe id='iframeId' name='iframeName'&gt;如果浏览器不支持，会显示iframe标签之间的文字&lt;/iframe&gt;``var iframe = window.frames['iframeName']` # 获取iframe.document.getElementById('iframeId')`iframe.contentWindow` #获取iframe窗口的window对象`iframe.contentWindow.postMessage('传给爸爸的信息'，'iframe的域，当然也可以写成*表示任意域')`# someWindow 接收数据的window# data 就是传输的数据# - html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象# - 并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，最好JSON.stringify()方法对对象参数序列化# origin 字符串参数，指明目标窗口的源,当然如果愿意也可以将参数设置为"* MessageEvent的属性1234567891011 someWindow.addEventListener('message',function(e)&#123; console.log(e.source) # 发送消息的窗口对象 console.log(e.origin) # 发送消息窗口的源（协议+主机+端口号） console.log(e.data) # 是传递来的message window.parent.postMessage('ok','*') # 处于安全考虑，需要判断域是不是发送消息的域 if(e.origin === 'xxx.sourceOrigin.com')&#123; # todo list window.postMessage('收到了爸爸的信息','爸爸的域') &#125;&#125;) 示例说明123456789101112131415161718192021222324252627# iframe里面嵌入的儿子页面 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;blog&lt;/title&gt; &lt;script&gt; window.onload=function()&#123; // 这个window就是儿子的window对象 window.addEventListener('message',function(e)&#123; console.log(e.source) console.log(e.data) console.log(e.origin) if(e.origin === '爸爸的origin') // 处于安全一定要校验是不是爸爸域发过来的消息 window.parent.postMessage('马上回来爸爸','*') // 给爸爸页面发消息 &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是跨域的儿子页面，在爸爸的iframe里面嵌入的页面&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 # 爸爸页面 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;blog&lt;/title&gt; &lt;style&gt; body &#123; height: 1000px; overflow: hidden; &#125; #myrame &#123; box-sizing: border-box &#125; #myrame1 &#123; box-sizing: border-box &#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; var iframe = document.getElementById("myrame"); var subBut = document.getElementById('buttons'); subBut.addEventListener('click',function(e)&#123; iframe.contentWindow.postMessage('儿子吃饭啦','*'); &#125;); window.addEventListener('message',function(e)&#123; console.log(e.source) console.log(e.data) &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe name="myiframe" id="myrame" src="b.html" frameborder="1" align="left" width="50%" height="100%" scrolling="auto"&gt; &lt;/iframe&gt; &lt;button id='buttons'&gt;叫儿子回家吃饭&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>浏览器跨域系列</category>
        <category>浏览器跨域系列（2）- 跨域和postMessage</category>
      </categories>
      <tags>
        <tag>postMessage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器跨域系列（1） - 跨域和jsonp]]></title>
    <url>%2F2018%2F10%2F23%2Fjsonp%2F</url>
    <content type="text"><![CDATA[跨域跨域简单的说就是浏览器处于安全方面的考虑，基于浏览器的同源策略，不允许不同域之间相互请求资源… 背景 Ajax只能够在同域下请求资源(ajax只能提交json,xml,text，html等文件类型的数据，如果二进制文件就需要使用formData) web页面上调用js文件时，不受是否跨域的影响（jsonp） 同源策略当 协议，子域名，主域名，端口中任意一个不相同时，就是不同域的，那么这两个域需要交互，就是跨域的：同源策略的限制包括： 不能Ajax(同源数据请求方式) 不能操作dom 不能共享Cookie、LocalStorage、IndexedDB 等存储性内容 但是有三个标签是允许跨域加载资源 123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt; 跨域需求一般进行跨域，都是基于两种需求： 1.跨域数据通信（简单的说就是共享数据或者数据传递） 2.跨域获取dom (例如获取iframe的高度) JSONP(跨域获取数据) 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP;缺点是仅支持 get方法具有局限性。 利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据 JSONP请求一定需要对方的服务器做支持才可以 该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 总结jsonp就是利用script标签可以不受浏览器同源策略的限制，通过get的方式跨域进行数据通信的方式，目前兼容型较好，但是只能支持get请求；目前jqery进行了封装 1.基本使用在客户端123456789&lt;script&gt; # 客户端根据指定的callback函数，定义对返回数据data的操作，例如alert出data的result属性 someCallBack(data)&#123; // todo with data alert(data.result); &#125;&lt;/script&gt;# 在script标签中引入跨域请求的url，必须指定callback给一个函数（必须），也可以传入其他参数(非必须)&lt;script src="www.crossDomainServer.com/remote.js?callback='someCallBack'&amp;userName='unclePis'"&gt;&lt;/script&gt; 在服务器端，只需要使用传入的函数将需要返回的json数据包裹返回就好，例如 1someCallBack(&#123;name:'root',password:'1233211234567'&#125;) 这样在客户端就相当于加载了一个js文件，调用定义好的函数 123456789 &lt;script&gt; # 函数声明 someCallBack(data)&#123; # todo with data alert(data.result); &#125; # 函数调用 someCallBack(&#123;name:'root',password:'1233211234567'&#125;)&lt;/script&gt; 2.动态添加123456789var someCallBack = function(data)&#123; # todo with data alert(data.result);&#125;var script = document.createElement('script');var src = "www.crossDomainServer.com/remote.js?callback='someCallBack'&amp;userName='unclePis'";script.setAttribute('src', url);# 把script标签加入head，此时调用开始document.getElementsByTagName('head')[0].appendChild(script); 3.jQuery的jsonp形式简单的说，jquery的dataType为jsonp的时候，就帮你封装了上面的基本实现，你只需要在success里面处理数据的返回就ok了，感觉好像ajax在同域请求资源一样123456789101112$.ajax(&#123; url:"http://crossdomain.com/jsonServerResponse", dataType:"jsonp", type:"get", # 可以省略,JSONP都是GET jsonpCallback:"fn",# -&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略 jsonp:"jsonp",# -&gt;把传递函数名的那个形参callback变为jsonp，可省略 success:function (data)&#123; console.log(data);&#125; &#125;), error: function()&#123; alert('fail'); &#125; JSONP和AJAX对比 JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式 但AJAX属于同源策略，JSONP属于非同源策略（跨域请求） 其他跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。之所以会跨域，是因为受到了同源策略的限制，同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 参考文章跨域几种方式jsonp原理详解——终于搞清楚jsonp是啥了]]></content>
      <categories>
        <category>浏览器跨域系列</category>
        <category>浏览器跨域系列（1） - 跨域和jsonp</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[verdaccio搭建私有npm仓库]]></title>
    <url>%2F2018%2F10%2F18%2Fverdaccio%2F</url>
    <content type="text"><![CDATA[搭建私有的npm仓库在私服上部署私有的npm仓库，一方面阅读原文 verdaccio123npm install verdaccio -g // 全局安装verdaccioverdaccio // 运行verdaccio 如何使用12345678# 当前npm 服务指向 本地 npm set registry http://localhost:4873 # 注册用户 npm adduser –registry http://localhost:4873# 按照提示输入userName 和 password,email#查看当前用户,是否是注册用户. npm who am i # 提示userName 进入工程目录发布私有package1npm publish 就成功发布了一个私有的包,就可以在其他模块里面使用 npm install [package name] 来安装了,而私有npm 里面不包含的包,例如你要安装一个vue ,webpack 这样的包,找不到的话,会被代理到 npm.js 官网去下载,并且会帮你缓存在 ./storage 文件夹里面. 再次下载,就能体验飞一般的速度了,当一个小团队使用的时候效果更佳. 由于考虑到时常会切换仓库来源,我是用了nrm ,一个仓库管理器,实际上就是 简化以下命令 npm set registry [url] 其他npm常用命令12345npm config set registry https://registry.npm.taobao.org # 通过config命令设置国内镜像npm config set registry http://registry.npmjs.org # 原npm地址npm config get registry # 如何检测镜像是否设置成功呢？即查看镜像的配置结果npm cache clean --force # 清除npm缓存 安装npm 仓库管理nrm(node registry manager) 使用nrm 进行npm registry地址管理和切换 1npm install -g nrm 添加sinopia/verdaccio 仓库地址 1nrm add myPrivateNpm http://xxx.xxx.xx.xx:4873 #myPrivateNpm是给私有仓库起一个名字，后面是sinopia/verdaccio运行私有仓库的地址 切换私有仓库1nrm use myPrivateNpm # 使用私有npm仓库]]></content>
      <categories>
        <category>verdaccio搭建私有npm仓库</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>npm</tag>
        <tag>verdaccio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript - 对象的常用操作(object)]]></title>
    <url>%2F2018%2F10%2F18%2Fobject%2F</url>
    <content type="text"><![CDATA[ObjectObject是js中比较常用的健值对，key只能是字符串，所以es6引入了map类型作为object的补充类型，下面对object的基本操作做一个汇总… 对象常用三连击var Obj = { userName:’unclepis’, age:30} Object.keys(obj) // [‘userName’,’age’]Object.values(obj) // [‘unclepis’,30]Object.entries(obj) // [[“userName”, ‘unclepis’],[“age”, 30]] ##.骚操作 2.1解构赋值var Obj = { userName:’unclepis’, age:30, gender:’male’} const { userName, // 基本解构操作 age, gender:sexual // 解构更名 phone=’7758521’ // 解构设置默认值，在undefined的时候加载默认} = Obj; 2.2with多操作var Obj = { userName:’unclepis’, age:30, gender:’male’}with(Obj){ userName=’hello world’, age:18, father=101 // 注意如果Obj中没有该属性会全局定义一个father = 101}// 等价于Obj.userName = “hello world”Obj.age= 18 2.3 in 操作符JavaScriptif(‘userName’ in obj) { // obj中存在userName返回true} 日常操作1)vue数据劫持的实现方式1234 Object.definePropery(Obj,&#123; set:function()&#123;&#125;, get:function(val)&#123;&#125;&#125;) 2）对象浅拷贝obj = Object.assign({},Obj,{ mother:’angle’, father:’god’}) 基本操作var Obj = { userName:’unclepis’, age:30, gender:’male’} for (var propName in Obj){ for…in遍历 if(Obj.hasOwnProperty(propName)){// 防止遍历原型属性 console.log(Obj[propName]) // 通过[propName]访问和Obj.propName访问 }}delete Obj.age // 删除操作]]></content>
      <categories>
        <category>javascript</category>
        <category>javascript - 对象的常用操作(object)</category>
      </categories>
      <tags>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript - 判断变量类型type]]></title>
    <url>%2F2018%2F10%2F18%2Ftype%2F</url>
    <content type="text"><![CDATA[#数据类型 最常见的判断方法：typeof1234567891011// 可以区分基本类型和undefinedtypeof '123' // 'string'typeof 123 // 'number'typeof true // 'boolean'typeof function test()&#123;&#125; // 'function'typeof undefined // 'undefined'// 对象类型无法区分typeof &#123;&#125; // 'object'typeof [] // 'object'typeof null // 'object' 判断已知对象类型的方法： instanceof null的typeof为object，function和undefined可以使用typeof 12345# 可以区分object和array分别是哪个构造函数的实例&#123;&#125; instanceof Object // true[] instanceof Array// truetest instanceof Function// truenew Date() instanceof Date// true prototype123456alert(Object.prototype.toString.call(‘123’) === ‘[object String]’) -------&gt; true;alert(Object.prototype.toString.call(123) === ‘[object Number]’) -------&gt; true;alert(Object.prototype.toString.call([]) === ‘[object Array]’) -------&gt; true;alert(Object.prototype.toString.call(new Date()) === ‘[object Date]’) -------&gt; true;alert(Object.prototype.toString.call(test) === ‘[object Function]’) -------&gt; true;alert(Object.prototype.toString.call(null) === ‘[object Null]’) -------&gt; true; ##基本类型 Stringtypeof // “string” Numbertypeof // ‘number’ Booleantypeof boolean // ‘boolean’ 特殊类型nulltypeof // 注意是‘object’ undefinedtypeof // ‘undefined’ functionfunction test(){}typeof test // ‘function’ ##变态类型objecttypeof // objectinstantceof Object // truefunctiontypeof // functioninstance of Function // truearraytypeof //objectinstance of Array // true]]></content>
      <categories>
        <category>javascript</category>
        <category>javascript - 判断变量类型type</category>
      </categories>
      <tags>
        <tag>type</tag>
        <tag>typeof</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6文档学习 - Map]]></title>
    <url>%2F2018%2F10%2F17%2Fmap%2F</url>
    <content type="text"><![CDATA[mapmap是es6引入的新的数据类型,常用的技术点： 初始化一个map，let newMap = new Map([[‘name’,age],[‘pis’,18]]) 增 newMap.set(1,2) 查询 newMap.get(1) 删 newMap.delete(1) 判断是否存在 newMap.has(1) // true Set的长度 newMap.size 数组和Set的数据转换 new Set([])/ Array.from(newSet) // 数组去重常用 Set的遍历方法 for…of keys,valus,entries和forEach 键值对js的Object对象的key只能是 字符串，为了使各种类型都可以当key，引入Map类型 初始化var map = new Map();map.set(1,1); 或者接受一个二维数组var map = new Map([ [‘name’, ‘张三’], [‘title’, ‘Author’]]); 设置/获取元素map.set(1,1)map.get(1) Map长度map.size 判断是否含有某个值map.has(1) 删除map.delete(1) 清除map.clear() 遍历方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 const map = new Map([ ['F', 'no'], ['T', 'yes'], ]);for (let key of map.keys()) &#123; console.log(key);&#125;// "F"// "T"for (let value of map.values()) &#123; console.log(value);&#125;// "no"// "yes"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// "F" "no"// "T" "yes"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"# 扩展运算符const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']]]]></content>
      <categories>
        <category>ES6文档学习</category>
        <category>ES6文档学习 - Map</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6文档学习 - Set]]></title>
    <url>%2F2018%2F10%2F17%2FSet%2F</url>
    <content type="text"><![CDATA[Setset是es6引入的新的数据类型,常用的技术点： 初始化一个set，let newSet = new Set([1,2,3]) 增 newSet.add(1) 删 newSet.delete(1) 判断是否存在 newSet.has(1) // true Set的长度 newSet.size 数组和Set的数据转换 new Set([])/ Array.from(newSet) // 数组去重常用 Set的遍历方法 for…of keys,valus,entries和forEach ##Set es6 引入的数据结构 类似数组 成员唯一，没有重复 Set本身是一个构造函数 初始化123var set = new Set(); 或者var set = new Set([1,2,3,3,34,5]) // 给Set构造函数传入一个数组 添加/删除元素12345var set = new Set();set.add(1);// 新增1set.add(2); // 新增2// add方法返回set数据本身，所以可以连续的add // set.add(1).add(2)set // [1,2] 删除set.delete(1); // 删除 判断是否包含元素set.has(1); // 判断是否含有1 set长度set.size // set的长度 清空setset.clear() set和数组类型的相互转换var set = new Set([1,2,3,4]) // 数组转换成setvar array = Array.from(set); // set转换成数组var array = […new Set([1,2,3,4])] 数组去重var arr = [1,2,3,4,4,4,4,5,5] function removeSameItem(arr){ return [… new Set(arr)]}removeSameItem(arr); 需要注意的点：123456789101112131415161718# NaN只能加入一个到setlet a = NaN;let b = NaN;a===b // false#但是 var set = new Set();set.add(a);set.add(b);set.size // 1#两个对象总是不相等的let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 遍历Set 结构的实例有四个遍历方法，可以用于遍历成员。keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 let set = new Set(['red', 'green', 'blue']);//---------------------------------------keys------------------------------for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// blue//---------------------------------------values------------------------------for (let item of set.values()) &#123; console.log(item);&#125;// red// green// blue//---------------------------------------entries------------------------------for (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]//---------------------------------------直接使用set------------------------------for (let x of set) &#123; console.log(x);&#125;//---------------------------------------forEach--------------------------------set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);// set没有key，所以key和value一样&#125;);扩展运算符JavaScriptvar set = new Set([1,2,3])var arr = [...set] // [1,2,3]数组的map和filter方法也可以间接用于 Set (调用数组的方法再转化成set)JavaScriptlet set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。JavaScriptlet a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125;]]></content>
      <categories>
        <category>ES6文档学习</category>
        <category>ES6文档学习 - Set</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6文档学习 - 模板字符串(spread string)]]></title>
    <url>%2F2018%2F10%2F17%2FspreadString%2F</url>
    <content type="text"><![CDATA[spread string为了解决变凉和字符串的拼接，并对某种字符串的空格和换行符进行原样输出，es6引入了字符串扩展功能… 字符串换行 字符串默认只能写在一行内，分成多行将会报错如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠；但是，输出的时候还是单行，效果与写在同一行完全一样 1234var longString = 'Long \long \long \string'; 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = 'Long '+ 'long '+ 'long '+ 'string'; ##es6可以使用`对字符串进行拼接,会保留换行和多个空格原样输出 1234var longString = `Long long long string`;]]></content>
      <categories>
        <category>ES6文档学习</category>
        <category>ES6文档学习 - 模板字符串(spread string)</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>spread string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本控制]]></title>
    <url>%2F2018%2F10%2F17%2Fgit%2F</url>
    <content type="text"><![CDATA[1.简介Git是目前世界上最先进的分布式版本控制系统（没有之一）。在一个多人合作的工作中，想删除一个段落，又怕将来想恢复找不回来怎么办？于是不得不对同一个文件建立多个不一样的副本;好不容易完成了自己需要编辑的部分，又需要再多个同事之间对协作完成的文件进行传输。使用Git就可以结束手动管理多个版本的刀工火种的时代，进入版本控制的新时代… 2.git仓库基础 工作区(work directory)：就是你在电脑上看见的目录，出了.git以外的区域 版本库(repository)：在工作区中有一个隐藏目录.git，这个不属于工作区，这是版本库. 缓存区(stage) master分支以及指向master的一个指针HEAD. add 实际上就是把工作区的文件修改添加到了缓存区。 commit就是把缓存区的内容提交到了当前分支，并清空了缓存区。 常用操作: ls // 查看目录下的所有文件 ls -ah // 可以查看文件夹下的隐藏文件。 ls -al // 查看文件夹下的所有文件，并列表显示 pwd//查看当前路径 cd path//访问路径文件 mkdir folder//创建路径文件 cat xxx // 查看文件内容 vi xxx // 对xxx文件进行编辑,i 进入编辑模式,dd 删除编辑模式中光标所在行,esc退出编辑模式 :wq 退出编辑模式后退出vi的编辑环境 git config –global user.name “Pis” git config –global user.email “email@163.com“ git config –list //查看git配置 git push origin –delete xxx //删除远程xxx分支 git branch -d xxx //删除本地xxx分支 git branch -D xxx //强制删除本地xxx分支 git tag //查看tag git tag -a tagName -m&quot;tag description&quot; commitId // 给版本的commit打tag git push origin tagName // 推送tag到远程仓库 git push origin --tags // 推送所有的tag 3.本地初始化一个git仓库 3-1.Desktop/web/git文件下创建git_test版本库 12cd Desktop/web/git mkdir git_test 3-2.初始化版本库 1git init //这时候git_test版本库下多了一个.git的目录，这个目录是git用来跟踪管理版本的。 3-3.手动把文件添加到版本库中 注: 所有的版本控制系统，只能跟踪文本文件的改动，比如txt，网页和所有的代码等。 3-4.把文件从工作区添加仓库的缓存区里面去 每当文件被修改之后，都需要重新add和commit 1234 git add readMe.md可以一次add多个文件，然后一起commitgit add file1.txt file2.txtgit commit -m "upload 2 files" 3-5.把文件提交到仓库当前分支上 git commit -m&quot;commit description&quot; 可以使用git status查看状态信息 可以使用git diff查看工作区和仓库文件的区别，也就是对比不一样的内容 可以使用git log查看历史纪录 如果感觉日志内容太多，可以git log --pretty=oneline 可以使用git reflog查看所有的历史操作 可以使用cat file查看file的内容 可以使用vi file查看文件的详细信息 - 当使用vi fileName的方式创建文件的时候，就进入写入模式，可以编辑文件内容，然后编辑结束按esc，再：wp就可以退出了。 可以使用:wq退出当前文件的查看状态 4.版本回退commit到master分支想要撤回到之前版本： 在git中，用HEAD表示当前版本。 git reset --hard HEAD^//回到上一个版本 git reset --hard HEAD^^//回到上上一个版本 git reset --hard HEAD~100//回到100个版本以前 git reset --hard commit_id//回到commit_id的版本 控制台不关闭，可以使用git log查看所有的commit版本记录； 控制台关闭过了，可以使用git reflog查看所有历史纪录的版本。 Git撤销修改和删除文件操作修改了文件发现文件的修改有误需要撤销修改 1. 手动在文件中删除做出的修改 （原始的做法，改错了直接手动该回去） 2. 使用git reset --hard HEAD^回到上一个版本 （已经add了，并且commit到本地的分支上） 3. 使用git checkout --file丢弃在工作区中的修改 （在工作区或者缓存区的修改） 1&gt;修改了文件还没有添加到缓存区，这就回到了版本库中的状态。（修改在工作区，还没有add） 2&gt;修改了文件并提交到了缓存区，回到了版本库缓存区的状态。 （修改在缓存区，已经add还没有commit） 总之就是让这个文件会到最近一次git commit或者git add的状态。总结: 只要没有commit，都可以使用git checkout --file恢复 commit了只能使用git reset --hard commit_id恢复到commit 5.远程仓库本地Git仓库和远程代码仓库之间的传输是通过SSH加密的 创建SSH Key1&gt;如果在用户主目录下有.ssh目录，查看有没有id_rsa和id_rsa.pub这两个文件 2&gt;没有的话，执行ssh-keygen -t rsa -C &quot;email@example.com&quot;，按照向导填写信息。 3&gt;id_rsa是私钥，不能泄漏出去；id_rsa.pub是公钥，可以放心的告诉别人。 4&gt;登陆远程代码仓库，在settings中SSH_Keys页面点击Add SSH Key，填上title在key文本里面粘贴id_rsa.pub文件的内容。 5&gt;这样远程代码仓库就可以识别出你推送的提交确实是你自己推送的，而不是别人冒充的，而git支持ssh协议。所以，远程代码仓库只要知道了你的公钥，就可以确定只有你自己才能推送。 6&gt;远程代码仓库允许添加多个key，这样如果你有多个电脑，比如一会在公司，一会在家提交，只需要把每台电脑的key都添加带远程代码仓库上，这样就好了。 本地Git仓库添加远程仓库 已经在本地创建好了Git仓库，想在github，coding或者gitee，gitlab等远程代码托管仓库上搭建一个远程Git仓库，希望这两个仓库远程同步，这样远程仓库可以作为备份，又可以其他人进行仓库来协作－－－－－－－－－在本地创建仓库－－&gt;托管到远程仓库－－－－－－－－－－－ 1.在github上创建一个git仓库git_test 2.在本地创建git仓库 mkdir Desktop/web/git/git_test pwd //可以确认是否已经进入git—_test git init//创建git_test的版本库.git文件 3.添加项目需要的文件在git_test文件夹里面 4.提交到本地master分支 git add file git commit -m&quot;file init&quot; 5.创建远程origin的git仓库 git remote add origin git@gitbub.com:unclepis/git_test.git git remote -v // 查看本地仓库和远程仓库的关系 git remote set-url origin git@gitbub.com:unclepis/git_test.git // 重新设置本地和远程仓库的关系 6.把本地git仓库master分支的内容推送到远程仓库 git push -u origin master//第一次 git push origin master//以后推送 从远程库克隆项目到本地 如果先有远程库，需要克隆到本地 1.登陆github创建一个新的仓库git_test 2.克隆到本地 git clone git@github.com:unclepis/git_test.git git clone git@github.com:unclepis/git_test.git newRepoName // 可以修改克隆下来的项目名称为newRepoName 创建与合并分支git checkout -b dev//创建并切换到dev分支 git branch //查看分支信息，当前分支前会有一个＊ git checkout dev //切换到dev分支 git merge dev //把dev分支合并到当前分支 git branch -d dev//删除dev分支 6.发生冲突- 本地发生冲突 git status cat file//查看发生冲突的文件 修改冲突的代码信息 add并commit - 远程仓库push后冲突，最好将冲突的分支拉到本地解决冲突 git fetch origin git merge origin/xxx // xxx冲突的分支 修改冲突的代码信息 add并commit 分支管理模式 Fast forward:快速模式，删除分支后会丢掉分支信息 -no-ff：禁用ff模式 分支管理流程 1.git checkout -b dev//创建一个dev分支。 2.修改readme.txt内容。 3.git add file git commit -m&quot;change file&quot;//添加到暂存区。 4.git checkout master//切换回主分支(master)。 5.git merge -no-ff -m&quot;merge with no ff&quot;dev// 合并dev分支 使用命令 git merge –no-ff -m “注释” dev 6.git branch -d dev//删除dev分支 7.git log//查看历史记录 分支管理策略 master主分支比较稳定，一般是用于发布新版本（release版本，一般master分支写保护了，不允许直接从本地master往远程的master分支推送） 干活在dev分支，完成后合并到master上发布。（开发dev分支） - 多人协作的项目，可以基于dev分支，建立每个人的xxxDev分支，然后合入到dev分支在测试环境进行测试 bug分支临时保存没有提交到版本库的手头工作dev,修复bug分支。 git stash//临时保存dev分支的工作 git checkout -b bug//创建并切换到bug分支 修改bug文件并add／commit git checkout master//切换到master分支 git merge -no-ff -m&quot;fix bug&quot; bug//把bug分支合并到master上 git branch -d bug//修复完bug删除bug分支 git checkout dev //回到dev分支继续干活 git stash list//查看stash list git stash apply //恢复stash内容并不删除 git stash drop//强制删除 git stash pop //恢复并删除stash内容 多人协作当从远程库克隆的时候，git会自动把本地的master分支和远程的master分支对应起来，并且默认的远程库是origin。 git remote //产看远程库的信息 git remote -v查看远程库的详细信息 git push origin master//推送本地master到远程master git push origin dev//推送本地的dev到远程的dev 多人协作流程 1.克隆git仓库到本地 git clone git@github.com:unclepis/git_test.git 2.进入本地库 cd git_test 3.创建分支开发dev git checkout -b dev origin/dev // 基于远程的dev分支建立一个dev，如果不指定，会基于当前所在分支建立本地分支 4.修改项目文件 git add file git commit -m&quot;modify file&quot; 5.合并dev到本地的master git checkout master// 切换到master git pull origin master // 更新本地的master git checkout dev git merge master git push origin dev 6.删除dev分支 git branch -d dev//删除dev分支 7.如果pull的时候没有建立本地和远程库的关系，需要先建立联系 git branch --set-upstream master origin/master // 旧的写法 git branch --set-upstream-to=origin/master master // 新的写法 git branch -u origin/feature feature // 或者写成这样 git branch --track feature origin/feature // 或者写成这样 git pull origin master --allow-unrelated-histories // 提示unrelated histories的强制做法 //例子：建立本地master和远程master的联系 8.提交文件然后再push git add file git comit -m&quot;fix conflict&quot; git push origin master 忽略特殊文件把不想提交的在git版本库目录下的文件隐藏到.gitingore下。]]></content>
      <categories>
        <category>git</category>
        <category>git版本控制入门基础</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git版本控制</tag>
      </tags>
  </entry>
</search>
